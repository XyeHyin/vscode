# 7月7日
## 包子凑数
### 题目描述
小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

**输入描述**
第一行包含一个整数 N $(1≤N≤100)$。



**输出描述**
一个整数代表答案。如以下 N 行每行包含一个整数 $A_i(1≤A_i≤100)$。果凑不出的数目有无限多个，输出 `INF`。

>输入
2
4
5

>输出
6

>样例说明
凑不出的数目包括：1, 2, 3, 6, 7, 11。
___


>输入
2
4
6

>输出
INF

>样例说明
所有奇数都凑不出来，所以有无限多个

`运行限制`
`最大运行时间：1s`
`最大运行内存: 256M`

### 题目分析
这道题目有一个很大的误导,就是它能凑出来的数跟他的奇数偶数是没有关系的,事实上,只要这些数的最大公约数不是1,也就是说它们不互质,那么就会有无限多个数凑不出来.
那么对于互质的数,我们可以先打表看看怎么个事
拿样例4,5举例:
$1,2,3$拿不出来
$4=4*1+5*0$
$5=4*0+5*1$
$6,7$拿不出来
$8=4*2+5*0$
$9=4*1+5*1$
$10=4*0+5*2$
$11$拿不出来
$12=4*3+5*0$
$13=4*2+5*1$
$14=4*1+5*2$
$15=4*0+5*3$
$16=4*4+5*0$
$17=4*3+5*1$
$18=4*2+5*2$
$19=4*1+5*3$
$20=4*0+5*4$
依此类推,后面的数我们也可以通过用前面的数加上我们刚推出来的数得到,我们可以发现,当顾客要的包子的数量大于一定数时,它一定能给出来,那么这个一定的数怎么找呢,它其实是$a*b-a-b+1$. 那么我们就可以给这个数组定边界了, 
`以下 N 行每行包含一个整数 $A_i(1≤A_i≤100)$`。
所以我们的边界不可能超过10000
然后就是寻找这道题的状态转移方程了,我们可以用dp[i]表示我们能否凑出i个包子,那么我们可以用$dp[j]$来更新$dp[j+a[i]]$.
最后我们只要统计一下dp数组中有多少个0就可以了.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b)
        ;
    return a;
}
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    int flag = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        flag = gcd(flag, a[i]);
    }
    if (flag != 1) {
        cout << "INF" << endl;
        return 0;
    }
    vector<int> dp(10005, 0);
    dp[0] = 1;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = a[i]; j < 10005; j++) {
            dp[j] = max(dp[j], dp[j - a[i]]);
        }
    }
    for (int i = 1; i < 10005; i++) {
        if (!dp[i]) {
            cnt++;
        }
    }
    cout << cnt << endl;
    return 0;
}
```
## 第几个幸运数字
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

到 X 星球旅行的游客都被发给一个整数，作为游客编号。X 星的国王有个怪癖，他只喜欢数字 3,5 和 7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。我们来看前10 个幸运数字是：`3579152125273545` 因而第 11 个幸运数字是：49 小明领到了一个幸运数字` 59084709587505`，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。

请你帮小明计算一下，

59084709587505 是第几个幸运数字。

`运行限制`
`最大运行时间：1s`
`最大运行内存: 128M`

### 题目分析
我们直接暴力就好,遍历所有3,5,7的幂次方的乘积,然后判断是否小于59084709587505,如果小于,那么我们就可以得到一个幸运数字,最后我们统计一下就可以了.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int cnt = 0;
    int ans = 59084709587505;
    for (int i = 0; pow(7, i) <= ans; i++) {
        for (int j = 0; pow(5, j) <= ans; j++) {
            for (int k = 0; pow(3, k) <= ans; k++) {

                if (pow(3, k) * pow(5, j) * pow(7, i) < ans)
                    cnt++;
            }
        }
    }
    cout << cnt << endl;
    return 0;
}
```