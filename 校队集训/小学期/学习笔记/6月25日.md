# $6$月$25$日学习报告 
## 递归学习
今天为了做昨天的21位花朵数的dfs部分,我们学习了递归
**递归**是一种解决问题的方法,它把一个问题分解为越来越小的子问题,直到问题的规模小到可以被很简单的解决.
### 反转数组
```cpp
#include <bits/stdc++.h>
using namespace std;
void f(int *a,int n){
    if(n==0) return;
    f(a+1, n - 1);
    cout << a[0] << " ";
}
int main(){
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    f(a,10);
    return 0;
}
```
这是一个递归的例子,它的功能是输出一个数组的所有元素,但是我们可以看到,它的递归部分是`f(a+1, n - 1);`这一句,它把问题的规模缩小了,这样就可以递归的调用自己,直到问题的规模缩小到0,这样就可以输出数组的所有元素了.
### 斐波那契数列
```cpp
#include <bits/stdc++.h>
using namespace std;
int fib(int n,int a,int b){
    if(n==0) return a;
    if(n==1) return b;
    return fib(n-1,b,a+b);

}
int main(){
    cout << fib(40, 0, 1);
    return 0;
}
```
在斐波那契数列中,传入的三个参数$n$是第几个数,而$a$和$b$是前两个数,通过让$a=b$并且在$b$上加上$a$的值,就可以得到下一个数,这样就可以递归的调用自己,直到$n=0$或者$n=1$时返回$a$或者$b$.
### 买票上车
题目描述：现有m个有0.5元的人，n个有1元的人需要上公交车，已知公交车费0.5元，司机可以找零，但司机目前没有零钱。问：有几种上车方案可以让司机为乘客找零？
>输入样例：3  2
输出样例：5
```cpp
#include <bits/stdc++.h>
using namespace std;
int f(int w,int y){
   if(w<y) return 0;
   if(y==0) return 1;
   return f(w-1,y)+f(w,y-1);
}
int main(){
    cout<<f(18,18);
    return 0;
}
```
紧接着是一个公交车问题,这个问题是这样的,有一个公交车,最开始没有零钱,票价是$5$毛钱,上来的顾客会给$5$毛钱和$1$元钱,如果是一元钱,公交车需要找还五毛钱,如果公交车没有多余的钱找零,那么这个方法就不是一个合理的方法,找出所有合理的方法一共有多少种.
通过递归的方法,我们传入的是付五毛钱和付一块钱的人的数量,如果付五毛钱的人的数量小于付一块钱的人的数量,那么这个方法就不是一个合理的方法,如果付一块钱的人的数量为$0$,那么这个方法就一定是一个合理的方法,这样就可以递归的调用自己,然后将下一位是付五毛钱的情况和下一位是付一块钱的情况相加,在下一层循环时继续重复此操作,就可以实现这个找到所有合理的方法了.
### 分苹果
题目描述：现有m个苹果，以及n个盘子，将苹果放在盘子里（盘子可以不全有苹果），问：有几种方案？
>样例：6  3
输出：7
```cpp
#include <bits/stdc++.h>
using namespace std;
// 提前声名
int f(int m, int n);
int g(int m, int n) {
    if (m < n)
        return 0;
    if (m == n)
        return 1;
    if (n == 1)
        return 1;
    return f(m - n, n);
}
int f(int m, int n) {
    if (n == 1)
        return 1;
    if (m == 1)
        return 1;
    if (n > m)
        return f(m, m);
    int sum = 0, i;
    for (int i = 1; i <= n; i++)
        sum += g(m, i);
    return sum;
}
int main() {
    cout<<f(6, 3);
    return 0;
}
``` 
有$m$个苹果,有$n$个盘子,每个盘子可能没有苹果,求有多少种方法,通过一个函数套函数的方法来解决,在`f`函数中代表的是盘子中没有苹果的情况,如果只有一个盘子或者一个苹果,返回一种情况,如果盘子的数量大于苹果的数量,那么就返回`f(m,m)`,代表无论有多少个盘子都是m个苹果放入m的盘子的情况,然后对剩下的苹果进行累加,累加时调用g函数,`g`函数代表 必须至少有一个,在`g`函数中,在处理边界后,把每个盘子都放入一个苹果,然后看作都没有放置苹果,再把就能把剩下的苹果放入`f`函数中继续递归
- 这种函数套函数我以前没有遇到过,感觉十分的神奇,同时理解起来也有点复杂,~~我觉得我很难自己写的出这种左脚踩右脚的写法~~(bushi)
 ### 汉诺塔
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  void  f(int n,char a ,char b , char c){
    if(n<=0) return;
    f(n - 1, a, c, b);
    cout<<a<<"->"<<c<<endl;
    f(n - 1, b, a, c);
    }
    int main(){
    f(3,'A','B','C');
    return 0;
   } 
  ```
  汉诺塔是一个经典的递归问题,通过递归的方法,我们可以把$n-1$个盘子从$A$柱子移动到$B$柱子,然后把第$n$个盘子从$A$柱子移动到$C$柱子,最后把$n-1$个盘子从$B$柱子移动到$C$柱子,这样就完成了整个汉诺塔的移动,这道题的关键我觉得在于`f(n - 1, b, a, c);`这里对递归函数的回溯,这样可以保持状态逻辑合理地延续下去.
  ### 小结
  对于递归,最重要的就是对于边界的处理,我们需要优先给我们的递归函数定义一个合理的出口,一个合理的出口才能保证我们的递归能够执行完毕,不然就会陷入无限的死循环中或者爆栈结束程序,在书写递归函数时,我们要把这个递归当作一个黑盒,只需要知道这个递归函数的功能,不需要知道这个递归函数是怎么实现的,这样就可以避免递归函数的逻辑错误,我觉得怎么读这个函数读的通顺是最关键的问题,把这个递归读作功能,然后接着往下写的时候把此递归部分看作最后一步,在函数后给它一个结尾,就能成功的写出一个递归函数了!

  ___
  ## 张老师的生日 
  #### (<small>博弈论或者离散数学?</small>)
**题目描述**
小明和小强都是张老师的学生，张老师的生日是M月N日，2人都知道张老师的生日是下列10组中的一天：

>3月4日 3月5日 3月8日
6月4日 6月7日
9月1日 9月5日
12月1日 12月2日 12月8日
张老师将M值告诉了小明，将N值告诉了小强，张老师问他们知道他的生日是哪一天吗？
小明说：如果我不知道的话，小强肯定不知道
小强说：本来我也不知道，但是现在我知道了
小明说：哦，那我也知道了
>据上面信息，推断出张老师的生日是哪一天？

- 通过小明说的第一句话,我们可以推断出小强不可能是 2和 5 否则小明无法断定小强一定不知道,所以小明一定不是12月和6月
- 小强又说,本来不知道,现在知道了,说明在小强的视角里,它可以选择的日期的相同日期和所在月一定无法大于3,不然无法达成小强本来不知道,现在又能确定,所以小强一定不是8日
- 最后小明说,我也知道了,同理说明小明也一定不能有三个同月份的选项,否则也无法直接判断出来,所以小明一定不是3月和6月
- 最后根据汇总的情报,小明一定不是3月和6月和12月,小强一定不是2日7日5日
- 所以张老师的生日是9月1日


  ___


  ## DFS与BFS
  接着是DFS与BFS,这俩真的是一个老生常谈的问题了,dfs使用的数据结构是栈,而bfs是队列.通过二叉树的先序遍历与后序遍历可以很形象的理解这个问题,对于dfs,就是先序遍历,而bfs就是后序遍历,也就是dfs先从"祖宗"杀起,而bfs是从"孙子"杀起,这样就可以很形象的理解这个问题了.dfs的先序遍历是中,左,右,而bfs的后序遍历是左,右,中.
  ### 经典例题
  `dfs`的经典例题就是N皇后了,这里以洛谷上的[P1219 [USACO1.5] 八皇后 Checker Challenge](https://www.luogu.com.cn/problem/P1219)为例
  ```cpp
  #include <bits/stdc++.h>
using namespace std;
int a[20][20] = {0};
bool test(int n, int m, int i) {
    int j;
    for (j = 0; j < m; j++) {
        if (a[j][i] == 1 || m + i - j < n && a[j][m + i - j] == 1 ||
            j + i - m >= 0 && a[j][j + i - m] == 1) {
            return false;
        }
    }
    return true;
}
int cnt = 0;
void hh1(int n, int m) {
    if (m == n) {
        cnt++;
        if(cnt<=3){
        int i, j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (a[i][j] == 1) {
                    cout << j+1 << " ";
                }
            }
        }
        cout << endl;
        }
        return;
    }
    int i;
    for (i = 0; i < n; i++) {
        if (test(n, m, i)) {
            a[m][i] = 1;
            hh1(n, m + 1);
            a[m][i] = 0;
        }
    }
}
void hh(int n) { hh1(n, 0); }
int main() {
    int _;
    cin >> _;
    hh(_);
    cout << cnt;
    return 0;
}
```
这是一个基础的做法,以二维数组来做,我们可以把它优化成一个一维数组来做;
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[20]={0};
int count = 0;
bool test(int n, int m, int i) {
    int j;
    for (j = 0; j < m; j++) {
        if (a[j]==i||a[j]==m+i-j||a[j]==j+i-m) {
            return false;
        }
    }
    return true;
}
void hh1(int n, int m) {
    if (m == n) {
        int i, j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if(a[i]==j) cout << "1 ";
                else cout << "0 ";  
            }
            cout << endl;
        }
        // cout << endl;
        ++::count;
        return;
    }
    int i;
    for (i = 0; i < n; i++) {
        if (test(n , m, i)) {
            a[m]=i;
            hh1(n, m + 1);
            //a[m][i] = 0;
        }
    }
}
void hh(int n) {
    int a[n];
    memset(a, 0, sizeof(int)*n);
    int count = 0;
    hh1(n, 0);
}
int main() {
    int _;
    cin >> _;
    hh(_);
    cout << ::count;
    return 0;
}
```
一维数组便优化好了,它是通过一个一维数组来存储皇后的位置,然后与y进行比较,如果在同一行或者同一列或者同一斜线上,那么就返回false,这样就可以很好的解决这个问题了.
**一维数组省去了回溯的操作,因为我们直接让`a[m]=i了`**
## 课后作业
### 1.用栈来解决N皇后问题
```cpp
#include <bits/stdc++.h>
using namespace std;

struct State {
    int x, y;
    int a[20][20];
};

int cnt = 0;

bool check(int a[20][20], int n, int x, int y) {
    for (int i = 0; i < x; i++) {
        if (a[i][y] == 1 || (y - x + i >= 0 && a[i][y - x + i] == 1) ||
            (y + x - i < n && a[i][y + x - i] == 1)) {
            return false;
        }
    }
    return true;
}

void f(int n) {
    stack<State> s;
    State ini = {0, 0, {}};
    s.push(ini);

    while (!s.empty()) {
        State cur = s.top();
        s.pop();

        if (cur.x == n) {
            cnt++;
            continue;
        }

        for (int y = 0; y < n; y++) {
            if (check(cur.a, n, cur.x, y)) {
                State state = cur;
                state.a[cur.x][y] = 1;
                state.x++;
                s.push(state);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    f(n);
    cout << cnt;
    return 0;
}
```
我们用结构体来表示处理的行列和棋盘目前的状态,对棋盘进行深搜,每次不停在栈中取堆顶,然后使用长度作为出口,但是在主体中我们不用递归的方式,而是用栈,我们在循环后检查是否满足边界条件,满足的话就把当前的棋盘状态压入栈,然后继续此操作,参考一维数组的方式这里就不用再进行回溯操作了,因为我们一直压入的都是当前的状态.
### 2.高IQ过河问题
[高IQ过河问题](https://www.4399.com/flash/252_1.htm)
#### 题目描述
`有一家六口人，包括爸爸、妈妈、两个女儿及两个儿子在旅行途中迷了路，还不幸遇上了一个逃狱的犯人，幸好犯人让一个也在旅行的警察逮捕，一家六口才得以保住性命。可是，在荒郊野外，手机接受不灵，他们都不能与外界联络，连警察也不能找到支援，他们只有通过一条河流方能回家，能帮帮他们么？`
玩家的任务是，帮助这些人渡过河，交通工具只有一艘小船。只有爸爸、妈妈以及警察能控制小船，此外，不论成人或是小孩，小船每次最多只能搭乘二人。在渡河期间，玩家还要防止以下三种情况发生：
1、当警察与犯人分开时，犯人会伤害一家六口。
2、当爸爸看见妈妈离开女儿时，爸爸便会教训女儿。
3、当妈妈看见爸爸离开儿子时，妈妈便会教训儿子。
#### 解题思路
正确的解法之一是:先是警察和犯人过去，警察回来，警察再带一个男孩过去，把犯人带回来，爸爸再带一个男孩过去，爸爸回来，爸爸妈妈过去，妈妈回来，警察犯人过去，爸爸回来，爸爸妈妈过去，妈妈回来，妈妈带一个女儿过去，警察犯人回来，警察带一个女儿去，再回来，把犯人带回来.
递归找出这种正确的解法

我需要定一些边界条件,在我的想法中,首先犯人必须一个人在一边或者跟警察在一起,不然就返回 return;
然后是如果爸爸和某个女儿在一边&&妈妈不在,那么就返回return;如果妈妈跟某个儿子在一边&&爸爸不在,那么就返回return;如果要移动的不是一个大人和一个小孩,那么就返回return;
我们可以开一个数组表示两岸,0表示这个人没过河了,然后一艘船的bool类型来代表船在哪一边
```cpp
#include <bits/stdc++.h>
using namespace std;
//0 小偷 1 警察 2 爸爸 3 妈妈 4 女儿1 5 儿子1 6 女儿2  7儿子2
vector<int> a(8, 0);
bool boat = 0;
bool check(int fir, int sec){
    if(a[0]^a[1]){
        for(int i = 2; i < 8; i++){
            if(a[i] == a[0]){
                return 0;
            }
        }
    }
    if(a[2]==a[4]||a[2]==a[6]){
        if(a[2]!=a[3])
        return 0;
    }
    if(a[3]==a[5]||a[3]==a[7]){
        if(a[3]!=a[2])
        return 0;
    }
    if(sec-fir>2){
        if(a[0]!=a[1]){
            return 0;
        }
    }
}
int main(){
    return 0;
}
```


今天只能推断到这里了,明天继续写
