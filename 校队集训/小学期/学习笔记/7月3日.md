# 7月3日
## 老周的运动
### 题目描述
老周最近几年日渐发福，因此决定运动起来。因为老周是程序员，喜欢有规律的运动。老周在三期操场上画出了坐标系，初始位置是$(x,y)=(0,0)$点 老周按照一定的规则进行跑步，面对坐标系上北下南左西右东。 起始时老周面朝东方，第i个阶段会向前走i米，并向左转。请计算老周经过n个阶段后的坐标。

**输入**
一行一个整数 n，代表老周跑的阶段数。$1\leqslant n \leqslant 2 \cdot 10^9$

**输出**
一行两个整数，表示老周n阶段后位置 x 和 y坐标，中间一个空格分隔。

**样例输入**
>5

**样例输出**
>3 -2
### 解题思路
![1721285754764.png](https://img.picui.cn/free/2024/07/18/6698bbd98ff09.png)
我们先按照题目要求把他模拟出来,找一找其中的规律,我们可以发现,坐标的集合为$(1,0),(1,2),(-2,2),(-2,-2),(3,-2),(3,4),(-4,4)\cdots \  \cdots $
| **row** | **col** |
| ------- | ------- |
| 1       | 0       |
| 1       | 2       |
| -2      | 2       |
| -2      | -2      |
| 3       | -2      |
| 3       | 4       |
| -4      | 4       |
| -4      | -4      |
| 5       | -4      |
| 5       | 8       |
| -6      | 8       |
| -6      | -8      |
| 7       | -8      |
| 7       | 16      |
| -8      | 16      |
| -8      | -16     |

到这里其实规律就已经找出来了,我们可以发现,x轴每两个为一组,x的值为偶数时,他是负数,奇数时是正数,y的值四个为一组,第一个是0当作特判,每组的前两个为正数,后两个为负数
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int x=0,y=0;
    int n;
    cin>>n;
    if(n%2==0) x=n/2;
    else x=(n+1)/2;
    if(x%2==0) cout<<'-';
    cout<<x<<" ";
    if(n==1) y=0;
    else{
        if((n-1)%4==0) y=((n-1)/4)*2;
        else y=((((n-1)/4)+1))*2;
    }
    if(((n-1)%4==0)||n%4==0)cout<<'-';
    cout<<y<<endl;
}
```
### 优化
我们更改一下逻辑就可以找到两个公式几行代码搞定
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    int x, y;
    x = (n + 1) / 2;
    if(x%2==0) x = -x;
    y = (n + 2) / 4 * 2;
    if((n+2)%4>=2) y = -y;
    cout<<x<<" "<<y<<endl;
    return 0;
}
```
## 称硬币
在研究最少砝码的问题之前,先引入一道经典的智力问题--称硬币
在研究称硬币问题之前,先解一道简单的硬币问题:
**在27个硬币中有一个硬币比其他的硬币轻,如何用天平称3次称出来**
- 我们可以先拿九个和另外九个比较,我们很明显的就能知道是3堆9个硬币中哪一堆轻了,小于就是左边轻,大于就是右边轻,等于就是剩下的那堆轻
- 再拿轻了的堆中的三个和三个比较,我们很明显就能知道是哪三个轻了
- 再拿一个和一个比较,我们就能知道哪一个轻了
  
***回到称硬币问题***
  ### 题目描述
  有13枚硬币。其中有12枚真币和一枚假币。假币和真币重量不同，但不知道假币比真币轻还是重。现在，用一架天平称了这些币三次，告诉你称的结果，请你找出假币并且确定假币是轻是重。
  ### 解题思路
  通过上面内个简单的问题,我们其实就可以知道天平可以一次称三堆硬币了,但是与上面的小问题不同的是,我们现在不知道了假币是轻了还是重了,所以我们就无法知道在称重的时候,哪一堆硬币是标准的,但是硬币无非就是两种情况,要么轻要么重,所以本来我们称三次可以称$3^3=9$,称n次就可以找出$3^n$个硬币是否有一个轻了,那么现在如果不知道硬币的轻重,我们知道的就是$3^n/2$个硬币,那么我们就可以通过这个方法找出假币了
  - 我们先将12个硬币分成3组,每组4个,我们可以把它们命名成$A_1,A_2,A_3$我们任选其中的两组进行称重,假如我们选的是$A_1$和$A_2$,那么我们无非得到的是三种情况,$A_1$轻,$A_1$重,$A_1$和$A_2$一样重我们一步一步来分析
  - 假设一样重的话,那么$A_3$里就有一个是假的,同时$A_1$和$A_2$一定都是真的,那么我们就可以把$A_3$分成两组,一组两个,一组三个,我们可以把它们命名成$B_1,B_2$,在真的两堆中随便取出三个,命名成$B_3$,拿$B_1$和$B_2$比较,如果一样重,那么$B_3$中有一个是假的,我们就可以找出假币了,如果不一样重,那么我们就可以知道假币是轻了还是重了,既然已经知道轻重了,那么问题就和上面的小问题一样了,$3^n=3$那么n就是1,也就是需要称一次,我们成功在三次拿下这道问题
  - 假设$A_1$重,我们把$A_1$中拿出三个,把$A_2$中拿出三个补给$A_1$,把$A_3$中拿出三个补给$A_2$
  - - 此时如果天平平衡了,那么就说明假币在$A_1$拿掉的三个中,而且假币轻了,此时再称一次就可以得到答案
  - - 如果天平反过来了,也就是$A_2$这一堆重,就说明$A_2$传给$A_1$的三个中有一个是假的,而且假币轻了,此时再称一次就可以得到答案
  - - 如果天平还是$A_1$重,那么就说明$A_1$没动的一个和$A_2$没动的一个中有一个是假的,我们拿一枚真币去跟它们比较一下就知道了
  - 假设$A_1$轻的方法和上面同理
  
  ### 编码分析
  我们现在需要做一个通用的递归程序做到在n个硬币时最少多少次能够找到坏的硬币
  ### 需求分析
  N个硬币,随机选一个为坏的,找到函数寻找坏了的硬币
  ### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int f(int n) {
    if (n <= 3) return 1 ;
    int heap = n / 3;
    int worst = 0x3f3f3f3f;
    for (int i = heap; i < heap + 2; ++i) {
        int peiping = n - 2 * i;
        worst = min(worst, 1 + max(f(i), f(peiping)));
    }

    return worst;
}

int main() {
    int n;
    cin>>n;
    cout<<f(n)<<endl;

    return 0;
}
```



## 最少砝码
### 题目描述
你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意 小于等于 N 的正整数重量。
那么这套砝码最少需要包含多少个砝码？
注意砝码可以放在天平两边。
输入格式
输入包含一个正整数 N。
输出格式
输出一个整数代表答案。

**样例输入**
>7

**样例输出**
>3

样例说明
3 个砝码重量是 1、4、6 可以称出 1  至 7 的所有重量。
$1 = 1$； 
$2 = 6 – 4$ 
$3 = 4 − 1$； 
$4 = 4$； 
$5 = 6 − 1$； 
$6 = 6$； 
$7 = 1 + 6$； 
少于 3  个砝码不可能称出 1 至 7   的所有重量。
评测用例规模与约定
对于所有评测用例，$1 \leqslant N \leqslant 1000000000 $
`运行限制`
` 最大运行时间：1s`
 `最大运行内存: 512M`

### 解题思路
我们可以通过硬币问题看出,对于天平来说,3很特殊,那么样例给出的说明其实不是最优解,最优解是1.3.9,这三个天秤能够表达的n为13,四个天秤就是1,3,9,27了,它能够表达的n为40,那么我们可以画一张表格,找出规律
| **砝码数** | **N** |
| ---------- | ----- |
| 1          | 1     |
| 2          | 4     |
| 3          | 13    |
| 4          | 40    |
| 5          | 121   |

规律已经很明显了,我们的$N_n=3 \cdot N_{n-1}+1$,那么我们输入的$N_n \leqslant N<N_{n+1}  $时, n就是我们要找的砝码数
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
//1,3,9,27一定是最优砝码
signed main(){
    int n;
    cin >> n;
    if(n == 1){
        cout << 1 << endl;
        return 0;
    }
    vector<int> a;
    a.push_back(1);
    for (int i = 1;;i++){
         a.push_back(a.back() * 3+1);
         if(a.back() >= n){
             cout << i+1 << endl;
             return 0;
         }
    }
        return 0;
}
```
## 后缀表达式
### 题目描述
给定 $N$ 个加号、$M$ 个减号以及 $N + M + 1$个整数 $A_1,A_2,⋅⋅⋅,A_{N+M+1}$​，小明想知道在所有由这 $N$ 个加号、$M$  个减号以及 $N + M +1$ 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？
请你输出这个最大的结果。
例如使用 `1 2 3 + -`，则 `"2 3 + 1 -"` 这个后缀表达式结果是 4，是最大的。
**输入描述**
第一行包含两个整数 $N$ , $M$ 
第二行包含 $N + M + 1$  个整数  $A_1,A_2,⋅⋅⋅,A_{N+M+1}$
其中， $0 \leqslant N,M \leqslant 10^5$，$-10^9 \leqslant A_i \leqslant 10^9$
**输出描述**
输出一个整数，代表答案。
输入输出样例

### 输入
>1 1
1 2 3

### 输出
>4

## 题目分析
这道题其实跟后缀表达式关系不大,我们只需要知道,如果只有加法的话,给全部的数求和就行,而如果有减法的话,无论它有多个减法,我们都可以通过括号化成只有一个减法,所以我们只需要减去排序后数组中的第一个元素也就是最小的内个元素就可以了.如果有负数但它不全是负数的话,我们一定可以把它化成正数,所以求和变成了求绝对值的和。如果全是负的话,有1个负数无论如何要做加法或减法的左操作数，那样只有这个数是负数，其他的都是正的。
____

## 关于表达式
表达式的三要素是操作数个数、优先级和结合性
#### 操作数个数

  大多数基本算术运算符（如`+`, `-`, `*`, `/`）都是二元运算符，意味着它们需要两个操作数,而单目运算符（如`-`, `!`）只需要一个操作数。

#### 优先级

  优先级决定了运算符的执行顺序。例如，在表达式 `(1+2)*3/4-(5+6)` 中，乘法和除法的优先级高于加法和减法。左括号的优先级最低，仅用于改变运算的顺序。

#### 结合性

  结合性决定了同优先级运算符的计算顺序。大多数算术和逻辑运算符是左结合的，意味着从左到右计算。但赋值运算符（如`=`和`+=`）以及某些单目运算符（如`-`, `!`, `&`, `*`）是从右向左结合的。`a+=b; a=b=1; -a; !a; &a; *a;` ,这些符号都是从右向左结合的

#### 使用栈进行中缀转后缀

为了将中缀表达式转换为后缀表达式，我们可以使用一个栈。
先初始化一个空的运算符栈和一个后缀表达式列表。然后直接在空栈中压入一个左括号,这么做的目的是让栈一直不为空,从而方便的判断是否结束运算,然后从左至右扫描中缀表达式中的每个字符。如果是操作数，直接添加到后缀表达式列表。如果是左括号`(`，压入栈。如果是运算符，与栈顶运算符比较优先级：如果栈为空或栈顶运算符优先级更低，压入栈。如果栈顶运算符优先级更高或相等，则将栈顶运算符弹出并加入后缀表达式列表，重复此步骤直到当前运算符可以压入栈。如果是右括号`)`，则连续弹出栈顶运算符并加入后缀表达式列表，直到遇到左括号并将其丢弃。表达式扫描完成后，将栈中剩余的运算符依次弹出并加入后缀表达式列表。

#### 计算后缀表达式的值
使用一个栈存储操作数。遇到数字，压入栈。遇到运算符，从栈中弹出两个操作数，进行计算，将结果压回栈.当所有元素处理完毕，栈顶元素即为表达式的值。

