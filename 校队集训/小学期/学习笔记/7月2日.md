# 7月2日
## 答疑
### 题目描述
有𝑛位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。
老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。 一位同学答疑的过程如下：
- 首先进入办公室，编号为 𝑖的同学需要 $𝑠_𝑖$毫秒的时间。
- 然后同学问问题老师解答，编号为 𝑖的同学需要 $𝑎_𝑖$毫秒的时间。
- 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。
- 最后同学收拾东西离开办公室，需要$𝑒_𝑖$毫秒的时间。一般需要 10秒、20秒或 30秒，即 $𝑒_𝑖$,取值为 10000,20000 或 30000。
  
一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。

答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群 里面发消息的时刻之和最小。

**输入描述**
输入第一行包含一个整数 𝑛，表示同学的数量。接下来 𝑛行，描述每位同学的时间。其中第 𝑖行包含三个整数 $𝑠_𝑖, 𝑎_𝑖, 𝑒_𝑖$，意义如上所述。
其中有 $1\leq n \leq 1000,1\leq s_i \leq 60000,1\leq a_i \leq 10^6, e_i \in 10000,20000,30000,$即$e_i$ $10000、20000、30000$之一
**输出描述**
输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。

### 输入输出样例
#### 示例
**输入**
>3
10000 10000 10000
20000 50000 20000
30000 20000 30000

**输出**
>280000

### 解题思路
这道题其实就是一道很简单的结构体排序题,唯一需要注意的就是排序规则的限制,我们需要先排序$s+a+e$的和最小的人,如果总数相等了,再排序$s+a$最小的人,因为当我们计算两个人的时候,假设只有两个数据,我们比较的是 
\[
\left\{
\begin{array}{l}
s_1+a_1+e_1+s_2+a_2+s_1+a_1 \\
s_2+a_2+e_2+s_1+a_1+s_2+a_2
\end{array}
\right.
\]
化简一下易得
\[
\left\{
\begin{array}{l}
s_1+a_1+e_1 \\
s_2+a_2+e_2
\end{array}
\right.
\]
所以这就是我们需要比较的东西,同时,当他们三者的和相等时,我们更需要的是s+a更小的人,或者说e更大的人,这样会让等待的时间变得更小
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int summing=0;
struct student{
    long long s, a, e, sum,sum2;
};
bool cmp(student a, student b){
    if(a.sum2==b.sum2) return a.sum < b.sum;
        return a.sum2 < b.sum2;
}

signed main(){
    int n;
    cin >> n;
    vector<student> v(n);
    for (int i = 0;i<n;i++){ 
        cin >> v[i].s >> v[i].a >> v[i].e;
        v[i].sum = v[i].s + v[i].a;
        v[i].sum2 = v[i].s + v[i].a + v[i].e;
    }
   sort(v.begin(), v.end(), cmp);
    vector<int> ans;
    summing += v[0].s + v[0].a;
    int answe=v[0].s + v[0].a;
    for (int i = 1; i < n;i++){
        summing += v[i].s + v[i].a+v[i-1].e;
        answe+=summing;
        }
    cout << answe;
    

        return 0;
}
```
##  等差素数列
### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。
$2,3,5,7,11,13,.... $是素数序列。 类似：$7,37,67,97,127,157$ 这样完全由素数组成的等差数列，叫等差素数数列。
上边的数列公差为 30，长度为 6。
2004 年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！
有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：
长度为 10 的等差素数列，其公差最小值是多少？

### 解题思路
&emsp;&emsp;这道题我们可以去使用一些容器去实现,首先,我们需要一个map,在map中我们的键设置为所有可能的公差,值设置为多个从x到y的等差数列用结构体实现,我们只需要记录这部分等差数列的起点到终点,然后不断地更新终点,例如,在键为2的值中,我们可以找到 $<3,11>$ ,在我们找到11和13的公差也是2时,而被减数刚好是这个结构体的终点,那么我们就可以改变这个结构体的值,也就是变成 $<3,13>$,如果找不到,那么需要在这个结构体的数组中加入一个新的结构体,把起点定为被减数,终点定为减数,也就是 $<11,13>$ 那么我们的map中的一行就可能可以展示为$2:<3,7>,<11,13>,\dots$这个样子.
&emsp;&emsp;重新梳理一遍,我们需要的最大的容器是一个map,map是一个键为int类型,值为set类型的容器,set是一个我们自定义了结构体的类型的容器,结构体中存放这的是这段子序列的首尾.
| key | value                                                     |
| --- | --------------------------------------------------------- |
| 2   | \<3,7> <11,13> <17,19> <29,31> <41,43> <59,61> <71,73> ···  |
| 4   | \<3,11> <13,17> <19,23> <37,41> <43,47> <67,71> <79,83> ··· |
| 6   | <7,19> <5,29> <31,43> <41,59> <61,79> <83,89> <97,109> ··· |
| ··· | ···                                                       |

那么我们只需要找到长度为10的等差素数列,他的key就是我们要的答案,比如说,如果$end-begin=key*(n-1),key$就是我们要的答案
### 代码实现
```cpp
// 答案是210,直接输出即可
#include <iostream>
using namespace std;
int main() {
    // 请在此输入您的代码
    printf("210");
    return 0;
}
// 下面是算出210的C++代码
#include <cmath>
#include <deque>
#include <iostream>
#include <map>
#include <set>
using namespace std;
struct T {
    int from, to;
    T(int f, int t) : from(f), to(t) {}
    bool operator<(const T &right) const { return to < right.to; }
};
int main() {
    deque<int> d;
    map<int, set<T>> m;
    d.push_back(3);
    int i, j, from, to;
    for (i = 5;; i += 2) {
        int sqrti = (int)sqrt(i);
        for (j = 0; d[j] <= sqrti; j++)
            if (i % d[j] == 0)
                break;
        if (d[j] > sqrti) {
            to = i;
            for (j = 0; j < d.size(); ++j) {
                from = d[j];
                set<T> &set_t = m[to - from];
                set<T>::iterator re = set_t.find(T(0, from));
                if (re != set_t.end()) {
                    T temp = *re;
                    set_t.erase(re);
                    set_t.insert(T(temp.from, to));
                    if ((to - temp.from) / (to - from) == 9) {
                        cout << (to - from) << endl;
                        goto L;
                    }

                } else {
                    set_t.insert(T(from, to));
                }
            }
            d.push_back(i);
        }
    }
L:;
    // map<int,set<T> >::iterator re;
    // for(re=m.begin(),i=0;re!=m.end()&&i<3;re++,i++)
    // {
    //         cout<<re->first<<":";
    // for(set<T>::iterator rere=
    // re->second.begin();rere!=re->second.end();rere++)
    //    cout<<"("<<rere->from<<","<<rere->to<<") ";
    //        cout<<endl;
    // }
}
```
注释中的代码是查看表的结果.
### 优化
这道题我们可以用$O(1)$实现,我们用脑子随便一想就可以知道,我们要求长度为$n$的等差数列子序列,他的公差一定等于一到n的所有质数相乘,也就是说,长度为10的等差数列子序列的公差一定是$2*3*5*7=210$,非常的邪门.
```python
print(2*3*5*7)
```

## 测试次数
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**
X 星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。
X 星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的 2  楼。
如果手机从第 7 层扔下去没摔坏，但第 8 层摔坏了，则手机耐摔指 =7 。 特别地，如果手机从第 1 层扔下去就坏了，则耐摔指数 =0 。 如果到了塔的最高层第 n 层扔没摔坏，则耐摔指数 =n 。
为了减少测试次数，从每个厂家抽样 3 部手机参加测试。
某次测试的塔高为 1000 层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

**请填写这个最多测试次数。**

运行限制
`最大运行时间：1s`
`最大运行内存: 128M`

### 解题思路
&emsp;&emsp;我们可以不顺着题目的思路想,我们去找出3个手机在砸多少次的时候能够得到1000层,那么这道题就很好写了,在只有一个手机的时候,我们只能砸i次得到i层的结果,因为一个手机只能一层一层去砸着看,两个手机的时候,当我们随便砸一个,如果手机被砸坏了,那么我们还剩下的手机数就是上一层的少一次砸的机会的结果,如果手机没有砸,那它的结果就是这一层可以砸的数减1,两种情况相加加上你砸的这一次就是这道题的状态转移方程了
|     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
|  0   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11   |
|  1  | 0   | 1   | 3   | 6   | 10  | 15  | 21  | 28  | 36  | 45  | 55  | 66   |
| 2   | 0   | 1   | 3   | 7   | 14  | 25  | 41  | 63  | 92  | 129 | 175 | 231  |
| 3   | 0   | 1   | 3   | 7   | 15  | 30  | 56  | 98  | 162 | 255 | 385 | 561  |
| 4  | 0   | 1   | 3   | 7   | 15  | 31  | 62  | 119 | 218 | 381 | 637 | 1023 |
| 4   | 0   | 1   | 3   | 7   | 15  | 31  | 63  | 126 | 246 | 465 | 847 | 1485 |

状态转移方程为: $dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+1$
然后我们只需要找到当$i==3$时,$j==?$的时候,$dp[i][j]>=1000$即可
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int a[100][100]={0};
    for(int i=0;i<100;i++){
        a[0][i]=i;
        a[i][0]=0;
    }
    for(int i=1;i<100;i++){
        for(int j=1;j<100;j++){
            a[i][j]=a[i-1][j-1]+a[i][j-1]+1;
        }
    }
    for (int i = 0; i < 100;i++){
        if(a[2][i]>1000){
            cout << i;
            break;
        }
    }

        return 0;
}
```
## K倍区间
### 题目描述
给定一个长度为 N 的数列， $A_1​,A_2​,⋯A_N$ ​，如果其中一段连续的子序列  $A_i​,A_{i​+1},⋯A_j$​ <small>$( i \leq j )$</small> 之和是 K 的倍数，我们就称这个区间  $[ i , j]$ 是 $K$ 倍区间。
你能求出数列中总共有多少个 $K$ 倍区间吗？

**输入描述**
第一行包含两个整数 N  和 K$( 1\leq N,K\leq 105 )$。
以下 N 行每行包含一个整数 $A_i​ (1\leq A_i​ \leq 105)$

**输出描述**
输出一个整数，代表 K 倍区间的数目。

### 输入
>5 2
1
2
3
4
5

### 输出
>6

`运行限制`
 `最大运行时间：2s`
`最大运行内存: 256M`

### 解题思路
&emsp;&emsp;这道题我们如果暴力的使用前缀和的话去遍历的话,时间复杂度是$O(n^2)$,这样的时间复杂度是不可接受的,会导致TLE
&emsp;&emsp;我们可以通过同余原理,假设有数的串为xxxxxxyyyyyyy，一堆x加起来%k得n，一堆x和y加起来%k也得n，那么这一堆y的和就是n的倍数。
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    ll n, k;
    cin >> n >> k;
    vector<ll> a(k,0);
    ll x, y=0;
    for(ll i = 0;i<n;i++){
        cin >> x;
        y=(y+x)%k;
        a[y]++;
    }
    ll sum = 0;
    for(ll i = 0;i<k;i++){
        sum += a[i]*(a[i]-1)/2;
    }
    sum += a[0];
    cout << sum;
    return 0;
}
```