# 7月1日学习报告
# 暨6月28日教师赛题解
## A.放麦子
### 题目描述

你一定听说过这个故事。国王对发明国际象棋的大臣很佩服，问他要什么报酬，大臣说：请在第 1个棋盘格放 1 粒麦子，在第 2 个棋盘格放 2 粒麦子，在第 3个棋盘格放 4粒麦子，在第 4个棋盘格放 8 粒麦子，......后一格的数字是前一格的两倍，直到放完所有棋盘格（国际象棋共有 64格）。 国王以为他只是想要一袋麦子而已，哈哈大笑。 当时的条件下无法准确计算，但估算结果令人吃惊：即使全世界都铺满麦子也不够用！ 请你借助计算机准确地计算，到底需要多少粒麦子

**输入**
>无

**输出**
>按要求输出答案
### 解题思路
这道题大的意思其实就是让我们求 $2^0+2^1+2^2+2^3+...+2^{63}$ 的值。这个数是一个等比数列的和，可以用等比数列的求和公式来求解。公式为：$S_n=a_1\frac{1-q^n}{1-q}$，其中 $S_n$ 是等比数列的和，$a_1$ 是首项，$q$ 是公比，$n$ 是项数。这里的首项$a_1=1$，公比 $q=2$，项数 $n=64$ ，所以 $S_{64}=1\cdot \frac{1-2^{64}}{1-2}=2^{64}-1$ 。所以答案就是 $2^{64}-1$。
**其实这道题很好想,我们需要求的是 $\sum_{n=0}^{63} 2^n$ ,在计算机的思想中, $\sum_{n=0}^{x} 2^n$ 其实就是二进制下的无数个 1,所以我们直接用上一位 $-1$ 就可以了。**
### 代码实现
```python
print((1<<64)-1)
```

## B.刘谦的魔术
### 题目描述
2024年央视春节联欢晚会上，刘谦表演了一个基于约瑟夫环问题的魔术。 魔术操作步骤如下： 1、 准备4张不同的扑克牌，随机打乱，即为ABCD； 2、 将4张扑克撕成两半，变成8张，排列为ABCDABCD； 3、 根据名字的长度n，循环n次：将最上面牌放到最下面。假设，n=6，此时，排列为CDABCDAB； 4、 将上面3张牌，放在最后1张牌和第1张（原第4张）之间，此时第1张和最后一张均为B，其他则任意次序，排列为BXXXXXXB； 5、 将第1张放在屁股下面，此时，屁股下为B，剩余排列为XXXXXXB； 6、 南北方人拿上面1或2张牌，随意插入到最后1张之前，排列仍为XXXXXXB； 7、 男生或女生扔掉上面1张或2张，这里以女生为例，排列为XXXXB； 8、 见证奇迹的时刻，循环7次：将最上面牌放到最下面，排列为XXBXX； 9、 好的留下来，将最上面牌放到最下面，排列为XBXXX； 10、 不好的丢出去，扔掉第1张牌，排列为BXXX； 11、 好的留下来，将最上面牌放到最下面，排列为XXXB； 12、 不好的丢出去，扔掉第1张牌，排列为XXB； 13、 好的留下来，将最上面牌放到最下面，排列为XBX； 14、 不好的丢出去，扔掉第1张牌，排列为BX； 15、 好的留下来，将最上面牌放到最下面，排列为XB； 16、 不好的丢出去，扔掉第1张牌，排列为B； 17、 此时，剩下的B和屁股下面的恰好是同一张牌。 假设，4张打乱后的扑克牌，恰好为JQKA。

### 输入
第一行是整数M，表示有M个问题。 接下来的M行，每行三个整数N、A、X，其中，N表示名字的长度，A是1或2表示南北方，X是1或2表示男女。

### 输出
每行一个数，与输入相对应的，剩下的那张牌对应的字符。

### 样例输入
>2
2 2 2
3 1 1

### 样例输出
>Q
K

### 解题思路
做这道题的时候,模拟扑克牌很像一个队列,所以我用队列来进行了逐步的模拟,我发现,当模拟到`4、 将上面3张牌，放在最后1张牌和第1张（原第4张）之间，此时第1张和最后一张均为B，其他则任意次序，排列为BXXXXXXB；`时,其实队列的头,也就是'B'其实就是我们要找的答案,所以到这里为止直接输出就可以了。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
string dic = "JQKAJQKA";
int main() {
    int m;
    cin >> m;
    while (m--) {
        queue<int> q;
        for (int i = 0; i < 8; i++) {
            q.push(i);
        }
        int n, a, x;
        cin >> n >> a >> x;
        for (int i = 0; i < n; i++) {
            int tmp = q.front();
            q.pop();
            q.push(tmp);
        }
        q.pop();
        q.pop();
        q.pop();
        cout << dic[q.front()] << endl;
    }
    return 0;
}
```
### 老师的代码版本
老师的代码更牛,直接对n+3取模,代表根据名字长度%4也就是四张牌后换掉三张的内一张,直接就可以得出答案了。
```cpp
int main() {
    char s[] = "JQKA";
    int m;
    scanf("%d", &m);
    while (m--) {
        int n, x, y;
        scanf("%d%d%d", &n, &x, &y);
        printf("%c\n", s[(n + 3) % 4]);
    }
}
```
## C.既约分数
### 题目描述
分子和分母的最大公约数为1的分数，被称为既约分数。例如，8/1、8/3、3/8等等，都是既约分数，请问分子和分母都在[1,2024]之间的既约分数有几个？

### 输入
>无

### 输出
> 按要求输出答案

### 解题思路
~~这道题其实就是求$1\leq x \leq 2024,1\leq y \leq 2024$的互质数的个数,这个数是一个莫比乌斯函数的值,莫比乌斯函数的定义是$\mu(n)=\begin{cases} 1 & \text{若} n=1 \\ (-1)^k & \text{若} n=p_1p_2p_3...p_k \\ 0 & \text{若} n \text{有平方数因子} \end{cases}$,所以我们可以直接用莫比乌斯函数的定义来求解这道题。~~
这是一道非常简单的题,因为数据小我们直接暴力就行, 8/3 3/8算两个,8/8算一个,代码如下:
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b);
    return a;
}
int main() {
    int count = 0;
    for (int i = 1; i <= 2024; i++) {
        for (int j = i; j <= 2024; j++) {
            if (gcd(i, j) == 1&&i!=j) {
                count+=2;
            }else if(gcd(i,j)==1&&i==j){
                count++;
        }
    }
    }
    cout<<count<<endl;
    return 0;
}
```

## D.退休次序
### 题目描述
假设男老师60岁退休，女老师55岁退休。院长想知道老师们的退休次序，请你为下面给出的身份证号码，根据退休的先后重新排序，存在同一天退休的情况时，请将身份证号码字典序小的放在前面
### 输入
第一行整数N，后面N行是N个身份证号码

### 输出
按要求的次序输出，每行一个身份证号码，以及该教师的退休日期，两项信息使用空格分隔

### 样例输入 
>2
211402197810030858
420503198307242348

### 样例输出 
>420503198307242348 20380724
211402197810030858 20381003

### 解题思路
这就是一道简单的结构体排序,我们用`substr`提取出他们退休的时间,然后按要求排序就好,身份证的倒数第2位代表了性别,~~但是这里写成s.size()-2不给过,写成[16]就过了,并不知道出了什么奇怪的bug~~,我现在知道我错哪了,不是s.size()-2是ss.size()-2,........................
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
struct teacher {
    string shenfenzheng, shijian;
};
bool cmp(teacher a, teacher b) {
    if (a.shijian != b.shijian) return a.shijian < b.shijian;
    return a.shenfenzheng < b.shenfenzheng;
}
int main() {
    int n;
    cin >> n;
    vector<teacher> s(n);
    for (int i = 0; i < n; i++) {
        string ss;
        cin >> ss;
        if (ss[s.size() - 1] == 'X')
            ss[s.size() - 1] = 0;
        string time = to_string(stoi(ss.substr(6, 4)) +
                                ((ss[16] - '0') % 2 == 0 ? 55 : 60));
        time += ss.substr(10, 4);
        s[i].shenfenzheng = ss;
        s[i].shijian = time;
    }
    sort(s.begin(), s.end(), cmp);
    for (int i = 0; i < s.size(); i++) {
        cout << s[i].shenfenzheng << " " << s[i].shijian << endl;
    }
    return 0;
}
```
## E.字符串年号
### 题目描述
小明用字母A对应数字1 ，B对应 2，以此类推，用Z对应26 。对于27以上的数字，小明用两位或更长位的字符串来对应，例如AA对应27，AB 对应28，AZ对应52，LQ对应329。

### 输入
一个1~10000之间的整数

### 输出
对应的字符串

### 样例输入
>2024

### 样例输出
>BYV

### 解题思路
这道题其实就是一个进制转换,比较特殊的是他的首位不是0而是A,所以我们在每次的短除的时候要先把这个数减一,然后再对26取模就是正确的转换了

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    string s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int n;
    cin >> n;
    string ans = "";
    while (n) {
        n--;
        ans += s[n % 26];
        n /= 26;
    }
    reverse(ans.begin(), ans.end());
    cout << ans;
}
```
## F.汉字谜面
### 题目描述
汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。16点阵的字库把每个汉字看成是16×16个像素信息。并把这些信息记录在字节中。一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。 把每个字节转为二进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是：
    第 1 字节，第 2 字节
    第 3 字节，第 4 字节
    ....
    第 31 字节, 第 32 字节

这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。
题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求再编写程序输出答案。
这段信息是（一共 10 个汉字）：
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 

### 输入
无

### 输出
请输出相应答案

### 解题思路
我们只需要将输入的数转化为二进制,然后只取后8位输出就可以了,因为一行是16个像素,所以一个字节我们只要它的8个像素
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    // for (int i = 0; i < 10;i++){
    //     for (int j = 0; j < 16;j++){
    //         for (int k = 0; k < 2;k++){
    //             int a;
    //             cin >> a;
    //             cout<<bitset<8>(a)<<" ";
    //         }
    //         cout << endl;
    //     }
    //     cout << endl << endl;
    // }
    unsigned long long ans = 1;
    for (int i = 0; i < 9;i++){
        ans *= 9;
    }
    cout << ans << endl;
    return 0;
}
```
注释内的部分可以打印出来十个16*16的01串,我们画出来可以看到说的是`九的九次方等于多少?` 输出即可;

## G.A和B
### 题目描述
有两个正整数A和B，A小于B。已知A和B的和X，以及A和B的最小公倍数Y，问A和B是多少？

**输入**
一个正整数N（N小于50），表示后面有N组数据，接下来的N行，每行两个整数X和Y$（0<X,Y<1e9)$

**输出**
输出N行，每行输出与输入相应的A和B，使用空格分隔。
### 样例输入 
>2
10 12
8 15

### 样例输出
>4 6
3 5

### 解题思路
比赛的时候我直接进行了暴力枚举,运气好1e9的数据都过了
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b);
    return a;
}

signed main(){
    int n;
    cin >> n;
    while(n--){
        int x,y;
        cin >> x >> y;
        for (int i = 0; i <= x / 2;i++){
            int lcm = i * (x - i) / gcd(i, x - i);
            if(lcm==y){
                cout << i << " " << x - i << endl;
                break;
            }
        }
    }
    return 0;
}
```
### 正解
正解其实是对公式的推导,我们可以得到$A+B=X,A*B=Y*GCD(X,Y)$,所以我们可以得到$A=X/2-\sqrt{X^2-4*Y*GCD(X,Y)}/2,B=X/2+\sqrt{X^2-4*Y*GCD(X,Y)}/2$,代码如下:
```cpp
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int main() {
    int n, x, y;
    cin >> n;
    while (n--) {
        cin >> x >> y;
        int z = gcd(x, y) * y;
        int delta = sqrt(x * x - 4 * z);
        cout << (-x + delta) / -2 << " " << (-x - delta) / -2 << endl;
    }
}
```
## H.指导小组合并
### 题目描述
计软学院有n个蓝桥竞赛指导小组，依次编号为1到n。第i个小组的学生数为ti。 由于这些小组的指导内容完全相同，院长认为应该合并成一个大组，统一培训节省成本。于是，院长和这些小组进行沟通，劝说小组和小组合并。 每次沟通院长需要请吃饭，并且一次只能邀请两个小组参加，花费钱数为两个小组的学生数之和乘以100，沟通的效果是两个小组联合成一个小组（学生数为原来两个小组的学生数之和）

**输入**
输入的第一行包含一个整数N，表示小组的数量。
第二行包含N个正整数，依次表示每个小组的学生数。
其中， $1\leq n \leq 1000,1\leq t_i \leq 10000$。

**输出**
输出一个整数，表示最小花费

### 样例输入 
>4
9 1 3 5

### 样例输出
>3100
### 解题思路 
我的思路是让它不断排序,最小的两个元素相加写到集合里,删除原来的两个元素,然后再排序,直到只剩下一个元素,这个元素就是答案
于是我们就有了它
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n;i++){
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    int xueshengshu;
    int cost = 0;
    while(a.size()!=1){
        xueshengshu = a[0]+a[1];
        cost += xueshengshu * 100;
        a.push_back(xueshengshu);
        a.erase(a.begin(),a.begin()+2);
        sort(a.begin(), a.end());
    }
    cout << cost << endl;
    return 0;
}
```
这样的时间复杂度是$O(n^2)$ ,我想到了这样不断的排序不就是优先队列吗,那么我们可以开一个递增的优先队列来优化,时间复杂度是$O(n\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i = 0; i < n;i++){
        int a;
        cin >> a;
        q.push(a);
    }
    int ans = 0;
    while(q.size()!=1){
        int a = q.top();
        q.pop();
        int b = q.top();
        q.pop();
        ans+=(a+b)*100;
        q.push(a + b);
    }
    cout<<ans<<endl;
    return 0;
}
```
这是我最后的代码,时间复杂度是$O(n\log n)$,空间复杂度是$O(n)$
## I.差的平方和
### 题目描述
有N个整数，请计算它们两两之间差的平方的总和

**输入**
一个正整数N（N小于等于100000），接下来一行有N个绝对值不超过100的整数。
**输出**
这些数两两之间差的平方的总和
### 样例输入
>3
1 2 3
### 样例输出
>6
### 解题思路
100000的数据太大了,我们正常的暴力肯定过不了.我们可以对数学公式进行一些计算化简从而在$O(n)$的时间复杂度内解决这个问题。根据$(a-b)^2=a^2+b^2-2ab$，
$\sum_{n = 1}^{a_n}(a_n - a_{n-1})^2 $= $\sum_{n = 1}^{a_n}a_n^2-2a_na_{n-1}+a_{n-1}^2$=$\sum_{n = 1}^{a_n}a_n^2-2\sum_{n = 1}^{a_n}a_na_{n-1}+\sum_{n = 1}^{a_n}a_{n-1}^2$
然后我们就可以找一些规律了,如图:
[![微信图片_20240701212500.jpg](https://img.picui.cn/free/2024/07/01/6682adec6bdc3.jpg)](https://img.picui.cn/free/2024/07/01/6682adec6bdc3.jpg)
我们就可以找到这样的规律$$\sum_{n = 1}^{n}(n-1)\cdot a_n^2-\sum_{n = 1}^{n}2a_n\cdot\sum_{a_n}^{n}a$$
简而言之,就是把每个数的平方$*(n-1)$倍加起来,然后减去$2*$这个数$*$这个数之后的所有数的和,最后算出来就是答案了
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n;
    cin >> n;
    vector<int> num(n);
    int sum = 0, sum1 = 0;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        sum1 += num[i];
    }
    for (int i = 0; i < n; i++) {
        sum += (n - 1) * num[i] * num[i];
        sum1 -= num[i];
        sum -= num[i] * sum1 * 2;
    }
    cout << sum;
    return 0;
}
```
我们找出的规律并不是最优的公式,以下是标准的公式推导

原始公式是： $$\sum_{n = 1}^{N}(a_n - a_{n-1})^2$$

展开后得到： $$=\sum_{n = 1}^{N}(a_n^2 - 2a_na_{n-1} + a_{n-1}^2)$$

这可以分解为三个部分： $$=\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1} + \sum_{n = 1}^{N}a_{n-1}^2$$

注意到，$\sum_{n = 1}^{N}a_{n-1}^2$实际上可以转换为$\sum_{n = 0}^{N-1}a_n^2$，因为它只是索引的偏移。因此，如果我们将$a_0$视为$0$（或题目中给定的初始值），这个公式可以简化为： $$=\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1} + \sum_{n = 0}^{N-1}a_n^2$$

由于$\sum_{n = 1}^{N}a_n^2$和$\sum_{n = 0}^{N-1}a_n^2$实际上是相同的（除了在$n=0$时可能的初始值之外），我们可以进一步简化为： $$=2\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1}$$

最终，我们得到简化后的公式： $$=2\left(\sum_{n = 1}^{N}a_n^2 - \sum_{n = 1}^{N}a_na_{n-1}\right)$$
## J.手拉手
### 题目描述
2个人有4只手，随机从4只手中选两只拉起来（注意：有可能自己左手拉右手），拉上以后不分开，再让未拉起来的两只手拉起来，此时，可能形成一个圈，也可能形成两个圈。形成一个圈的概率是2/3，形成两个圈的概率是1/3。
假设两个人为A、B，四只手AL、AR、BL和BR。第一次随机选两只所有的情况为：（AL、AR）、（AL、BL）、（AL、BR）、（AR、BL）、（AR、BR）和（BL、BR）；其中，（AL、AR）和（BL、BR）将形成两个圈，其余4种情况都是形成1个圈。

假设我校有1012名教师，就会有2024只手，现在为了显示大家很团结，随机从这些“手”中找不同的两只拉起来，拉上以后不分开，这样的操作可以进行1012次，问形成几个圈的概率最大？

**输入**
无
**输出**
按要求输出答案
### 解题思路
首先,有一种最简单的不用动脑子的方法就是一眼看过去就会发现概率最大的圈一定不会很大,~~所以我们用`cout<<1,2,3,4...`挨个往过试就好~~
最简单的方法就是此题没有变量,所以，我们可以根据大数极限定律,不断重复模拟这个实验足够多的数
看一下组成几个圈出现的次数最多，就是答案。 
模拟开始时，就是0—2023代表2024只手，随机数x就是选出的第一只手，随机数y(y!=x)
就另一只，x/2==y/2认为x和y来自于同一个人；下一轮模拟时，0---2021代表2022只
手，来自1011个人（上一轮手拉手的两个人，本轮可视为1个人).直至模拟到全部手
都拉上。 
```cpp
int main() 
{ 
    int count[1013]={0}; 
 int i,j; 
 for(i=0;i<10000;++i) 
 { 
  int c=0;//组成的圈数 
  for(j=0;j<1012;++j) 
  { 
   int x=rand()%(2024-j*2);//随机选一只手 
   int y; 
   while(y=rand()%(2024-j*2),x==y);//随机选另一只手 
   if(x/2==y/2)//若x/2等于y/2认为组成圈 
    ++c; 
  } 
  ++count[c]; 
 } 
 for(i=1;i<=1012;++i) 
  cout<<i<<" "<<count[i]<<endl; 
} 
```
运行以上代码，可发现出现4个圈的次数最多，所以答案就是4。
但是运行代码时,我发现每次的结果都是一样的,我感觉十分奇怪,为什么随机出来的结果是一样的,会不会是伪随机,那是不是说明如果是变量的话也是可以这么做的呢?于是我把上面老师的思路改变了一下
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n, m;
    cin>>n;
    m = 2 * n;
    int a[n] = {0};
    for (int j = 0; j < 10000;j++){
        int cnt = 0;
    int x, y;
    for (int i = 0; i < n;i++){
        x = rand() % (m-2*i);
        do{ y = rand() % (m-2*i);
        }while(x==y);
       
        if(x/2==y/2) cnt++;
    }
    a[cnt]++;
    }
    int max=max_element(a,a+n)-a;
    cout << max << endl;
        return 0;
}
```
由于没有判题机,我无法判断这样是不是可以AC
下面是这道题的正解,我们需要用`dp`去实现
[![微信图片_20240701214146.png](https://img.picui.cn/free/2024/07/01/6682b1caeddcd.png)](https://img.picui.cn/free/2024/07/01/6682b1caeddcd.png)
仔细观察上表，会发现$dp[i][j]=dp[i-1][j-1]/(2*i-1)+dp[i-1][j]*(2*i-2)/(2*i-1)$;，以 $dp[5][3]$为
例：$dp[5][3]= dp[4][2]*1/9+ dp[4][3]*8/9$。可解释为： 
5 个人形成3个圈的概率$=$4个人形成2个圈的概率乘以$1/9 + 4$个人形成3个圈的概率乘
以$8/9$。 
试想，5个人10只手，随意拿出一只，再从剩下9只手中，随机选1只，选中同一人的手
的概率$1/9$，不是同一人的手的概率$8/9$；所以，形成3个圈的概率，就是选中同一人的手
概率$1/9$乘以4个人2圈的概率，加上，未选中同一人的手概率$8/9$乘以4个人3圈的概
率。 
有了以上的转移方程，很容易写出以下代码。 
```cpp
double dp[1013][1013]; 
int main() 
{ 
int i,j; 
dp[1][1]=1; 
for(i=2;i<1013;++i) 
for(j=1;j<=i;++j) 
dp[i][j]=dp[i-1][j-1]/(2*i-1)+dp[i-1][j]*(2*i-2)/(2*i-1); 
for(i=0;i<=5;++i) 
cout<<i<<" "<<dp[1012][i]<<endl; 
} 
```
#### 优化
我们可以对这段代码进行状态压缩,从而使得空间复杂度由$O(n^2)$降低到$O(n)$
```cpp
int main() 
{ 
int i,j; 
double dp[1013]={0,1}; 
for(i=2;i<1013;++i) 
for(j=i;j>=1;--j) 
dp[j]=dp[j-1]/(2*i-1)+dp[j]*(2*i-2)/(2*i-1); 
for(i=0;i<=5;++i) 
  cout<<i<<" "<<dp[i]<<endl; 
}
```
## K.学生排队
### 题目描述
有J+R+W名专升本的学生在排队，其中计科专业J名，软工专业R名，网络专业W名。此时，老师发现，从前向后看这一列学生，连续t1个学生同一专业，连续t2个学生同一专业，……，连续tn个学生同一专业。

t1+t2+……+tn等于J+R+W。并且，t1<t2<……<tn。

那么请问在给定J、R、W，并且不区分同一专业学生的情况下，有几种不同的排列方案？

**输入**
输入第一行是案例数N，接下来每一行有3个整数J、R、W
其中， 0≤J、R、W≤50，0≤J+R+W≤90。

**输出**
输出N行，每行一个整数，表示与输入相应的答案。

### 样例输入
>2
3 6 0
1 1 1

### 样例输出
>3
0

**提示**
`3 6 0那组案例的答案是3：jjjrrrrrr,rjjjrrrrr,rrjjjrrrr`
`1 1 1那组案例的答案是0：无法给出单调递增的排列`
### 解题思路
这道题我们可以使用dfs,写递归先找非递归出口,如果所有专业的学生都空了,那么这就是一种可能,在dfs中传入当前的专业和当前的人数,然后遍历每个专业,尝试从当前连续学生数 t 开始，逐个减少该专业的学生数，然后递归调用，之后再将学生数回溯到上一个状态。我们从1个学生,没有专业开始考虑,最后找到可能的方案数ans

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int  a[10], ans;
void dfs(int t, int now) {
    if (!a[1] && !a[2] && !a[3]) {
        ans++;
        return;
    }
    for (int i = 1; i <= 3; i++) {
        if (i == now) continue;
        for (int j = t; j <= a[i]; j++) {
            a[i] -= j;
            dfs(j + 1, i);
            a[i] += j;
        }
    }
    return;
}
int main() {
    int n;
    cin >> n;
    while (n--) {
        ans = 0;
        cin>>a[1]>>a[2]>>a[3];
        dfs(1, 0);
        cout<<ans<<endl;
    }
    return 0;
}
```
以下是老师的做法:
深度优先搜索，就是一堆学生，从前向后排，尝试每一种情况。 
递归函数原型$f(j,r,w,n,z)$;，其中，j、r、w分别表示当前计科、软工、网工所剩学生数（未排列的学生数），n为前面连续同一专业的学生数（保证这轮摆放的学生数不能比前面的少），z为前面学生的专业（保证这轮摆放的学生专业不能与前面相同）。 
```cpp
int cnt;//全局变量保存答案  
void f(int j,int r,int w,int n,int z) 
{ 
 int i; 
 if(!j&&!r&&!w)//全部学生为0，找到1组解，非递归出口 
 { 
    ++cnt; 
    return; 
 } 
 if(z!='J')//前面学生不是计科，尝试放计科学生 
  for(i=n+1;i<=j;++i)//从n+1开始尝试  
   f(j-i,r,w,i,'J');  
 if(z!='R')//前面学生不是软工，尝试放计科软工 
  for(i=n+1;i<=r;++i)//从n+1开始尝试  
   f(j,r-i,w,i,'R');   
 if(z!='W')//前面学生不是网工，尝试放计科网工 
  for(i=n+1;i<=w;++i)//从n+1开始尝试  
   f(j,r,w-i,i,'W');    
}  
int main() 
{ 
    int n,j,r,w; 
    cin>>n;  
 while(n--) 
 { 
  cin>>j>>r>>w; 
  cnt=0;//全局变量回0 
  f(j,r,w,0,'X'); 
  cout<<cnt<<endl;  
 } 
}
```
## 今日总结
 今天将上周比赛的11道题全部写了题解,其中对于dp的状态压缩是我写不出来的,对于倒数第二题的dp的状态转移方程我也找不出来,上周比赛AC了9道题,最后的两道题没有时间看了,不过即使再给我时间我觉得当时我也不一定能做出来就是了,dfs和dp好难 `XD`