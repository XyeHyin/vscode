
# $6$月$24$日学习报告

## 花朵数计算

### 任务描述

   编写一个程序来寻找所有21位的十进制正整数，这些整数的每个位上的数字的21次方之和等于该整数本身。

### 定义

- **花朵数**：一个N位的十进制正整数，如果它的每个位上的数字的N次方之和等于这个数本身，则称其为花朵数。
- **例子**：
  - 当N=3时，153是一个花朵数，因为 $1^3 + 5^3 + 3^3 = 153$。
  - 当N=4时，1634是一个花朵数，因为 $1^4 + 6^4 + 3^4 + 4^4 = 1634$。
  - 当N=5时，92727是一个花朵数。

### 目标

求N=21时，所有满足条件的花朵数。输出所有符合条件的数字，每个数字占一行。

### 程序要求

- 输入：无
- 输出：所有21位的花朵数，每个数字占一行。
- 性能要求：程序应在1分钟内运行完毕。

### 示例输出
> 128468643043731391252
> 449177399146038697307

### 一.做题思路
#### 1.1 高精度
##### 自己的做法
起初拿到这道题的时候,21位数据的计算普通的数据类型肯定是 无法存储的,所以要使用到高精度,最开始我找到了洛谷上的高精度题并且进行了我的首次高精度尝试.
<https://www.luogu.com.cn/problem/P1601>
<https://www.luogu.com.cn/problem/P1303>
```cpp
string add(string a, string b) {
    if (a.size() < b.size()) {
        swap(a, b);
    }
    reverse(a.begin(), a.end());
    reverse(b.begin(), b.end());
    while (b.size() < a.size()) {
        b += '0';
    }
    int carry = 0;
    string ans;
    for (int i = 0; i < a.size(); i++) {
        int sum = a[i] - '0' + b[i] - '0' + carry;
        ans += sum % 10 + '0';
        carry = sum / 10;
    }
    if (carry) {
        ans += carry + '0';
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
```
```cpp
string multiply(string a, string b) {
    if (a.size() < b.size())
        swap(a, b);
    reverse(a.begin(), a.end());
    reverse(b.begin(), b.end());
    vector<string> res;
    for (int i = 0; i < b.size(); i++) {
        string ans;
        int carry = 0;
        for (int j = 0; j < a.size(); j++) {
            int sum = (a[j] - '0') * (b[i] - '0') + carry;
            ans += sum % 10 + '0';
            carry = sum / 10;
        }
        if (carry) {
            ans += carry + '0';
        }
        reverse(ans.begin(), ans.end());
        for (int j = 0; j < i; j++) {
            ans += '0';
        }
        res.push_back(ans);
    }
    string sum = res[0];
    for (int i = 1; i < res.size(); i++) {
        sum = add(sum, res[i]);
    }
    if (a == "0" || b == "0") {
        return "0";
    }
    return sum;
}
```
于是就有了非常~~derb~~的高精度做法,我只是通过字符串进行了处理,输入的参数和返回的参数都是字符串类型,调用起来十分的麻烦
通过这个方式写出来的main函数也十分的~~derb,虽然仅仅是暴力枚举,而且用了非常derb的方法解决老师要求的"INT"类型~~
```cpp
#define INT string
```
###### **老师的做法**
- 老师通过将大整型封装在一个结构体中,并且对大整型进行**运算符重载**,来方便的调用高精度进行运算
- 这个大整型**首先进行了数据结构的处理**,通过将21位数进行类似于10000进制的进制转换,存入数组当中(<small>数组的索引类似于16中abcde这种?</small>),这样它就能只在int范围下进行运算,而且因为只需要计算每个数的21次幂,这个数只会从1到9,所以它进行的是一个**大整型$\times$小整型**
- 
```cpp
struct Int {
    int arr[6];
    bool yc;
    Int(int n = 0) {
        memset(arr, 0, sizeof(int) * 6);//初始化
        yc = 0; // 是否发生溢出
        int i = 0;
        while (n) {
            arr[i++] = n % 10000;
            n /= 10000;
        }
    }

    // 将数据进行数据结构的处理
    Int(const char *s) {

        memset(arr, 0, sizeof(int) * 6);
        yc = 0;
        int i = 0;
        int len = strlen(s);
        // 长度超出21算21个数,不超出算当前的数位
        len = len <= 21 ? len - 1 : 20;
        int tmp;
        for (; len >= 0; --len) {
            if (i % 4 == 0)
                tmp = 0;
            tmp += (s[len] - '0') * pow(10, i % 4);
            if (i % 4 == 3|| len == 0) {
                arr[i / 4] = tmp;
            }
            ++i;
        }
    }
    //格式化输出
    void display()const{
        int i;
        bool flag=0;
        for(int i=5;i>=1;i--){
            if(flag||arr[i]){
                if(flag==0)  printf("%d",arr[i]);
                else printf("%04d",arr[i]);
                flag=1;
            }
        }
        if(flag) printf("%04d",arr[i]);
        else printf("%d",arr[i]);
    }
    // 运算符重载小于号
    bool operator<(const Int &b) const {
        int i;
        for (int i = 5; i >= 0; --i)
            if (this->arr[i] < b.arr[i])
                return 1;
            else if (b.arr[i] < this->arr[i])
                return 0;
        return 0;
    }
    // 运算符重载大于号
    bool operator>(const Int &b)const{
        return b < *this;
    }
    // 运算符重载小于等于号
    bool operator<=(const Int &b)const{
        return !(b<*this);
    }
    // 运算符重载大于等于号
    bool operator>=(const Int &b)const{
        return !(b>*this);
    }
    // 运算符重载等于号
    bool operator==(const Int &b)const{
        return !(*this<b)&&!(b<*this);
    } 
    // 运算符重载加等于号
    Int& operator+= (const Int &b){
        int i;
        int jin=0;
        for(i=0;i<6;i++){
            int tmp=arr[i]+b.arr[i]+jin;
            arr[i]=tmp%10000;
            jin=tmp/10000;
        }
        //因为是21位数,而数据结构开到了24位,所以理论上不会发生溢出的情况,只会有进位不满的情况
        if(jin)yc=1
        return *this;
    }
    //运算符重载加号
    Int operator + (const Int& b)const{
     Int tmp=*this;
     return tmp+=b;
    }
    //运算符重载乘等于号
    Int& operator *=(int b){
        int i;
        int jin=0;
         for(int i=0;i<6;++i){
            int tmp = arr[i]*b+jin
            arr[i]=tmp%10000;
            jin=tmp/10000;
         }
         if(jin) yc=1;
         return *this;
        }
    //运算符重载乘号
    Int operator *(int b){
        Int tmp=*this;
        return tmp*=b;
    } 
    
};
```
 - 对于这个版本的代码学习后我有几个点不懂:(弄懂后会加删除线捏)
- ~~构造函数中的int n=0不能很好的理解~~
- ~~对于重载运算符中的&符号和*符号不是很懂,貌似是指针?(bushi)~~
- ~~运算符重载后面的const是什么意思?~~
- #### 1.2 组合数
 -  如果通过暴力枚举的方式,一共要计算$10^{21}$次,这个是不现实的,所以我们要通过其他的方式来减少计算量,这里我们可以通过**组合数**来减少计算量
 -  首先通过提前打表可以将每个数的21次幂计算出来,减少每次计算的计算量
 -  ```cpp
     for (int i = 0; i <= 9;i++){
        INT ans = "1";
        for (int j = 1; pj <= 21;j++){
        ans = multiply(ans, to_string(i));
        }
        std::cout << ans<<endl;
    }
  >INT lst[10] = {
               {"0"},
               {"1"},
               {"2097152"},
               {"1046035F203"},
               {"4398046511104"},
               {"476837158203125"},
               {"21936950640377856"},
               {"558545864083284007"},
               {"9223372036854775808"},
               {"109418989131512359209"}};
               }


通过**插板法**,我们可以将 $21$个数加 $9$个板子分成 $9$个数,这样我们就可以通过$ C_{30}^{9} $来计算,计算出的每种情况代表板子分割开的数,比如一种可能的格式是 ${1,0,1,0,1,0,1,0,1,0}$ 它代表着我们可能可以选择 $1$个 $0,2,4,6,8$ ,   $0$个 $1,3,5,7,9$的方式,然后判断这些数的和是否是21位数,如果是的话就输出

___


 -  **对于$C_{30}^{9}$的解释**:
    如图:
    ![无标题.png](https://img.picui.cn/free/2024/07/18/6698cc2bd309c.png)
    这里使用的插板法和我们高中所学习的排列组合是不太一样的,因为它会有不选的情况,而高中所学的题大多数是至少有一个的情况,所以不能像正常插板法一样直接写成 $C_{20}^{9}$,对于 $C_{30}^{9}$中的 $9$不难理解,因为有 $9$块板子,而对于 $30$来说,我的理解是这样的$:$
    在实际做题中会发现,我们需要找到的是板子代表的数,表示板子左边有几个元素,而左边界的定义是在遇到下一块板子的时候就是左边界,所以最左边也是可以放板子的,代表 $0$的个数是$0$,而最右边是不需要放板子的,在上课的时候,老师说过一句话,$C_{4}^{3}$时我们是不需要求最后一块的数量的,因为只剩它了,所以在最右边是不用插板子的,此时板子的总数 就是 $20$个空 $+$ 最左边 $=21$;当我们把一块板子放下时,原本的一个空被板子分割成了两个空,也就是多一个空,因为会有  $0$个情况出现,所以所有板子一定多一个空,所以此时板子的总数就是 $21+9=30$  (个),所以我们要求的数就是 $C_{30}^{9}$.

    ---

 -  对于如何实现插板法,我们可以选择**递归**的形式,因为直接循环的话会有很多的重复计算,而且并不知道具体需要多少层循环,这取决于程序选择的数都是多少,所以我们可以选择$DFS$,它的特点是不撞南墙不回头,在搜索到最后才返回,可以减少非常多的计算量.
    代码实现:
    我们先递归找出在$C_{30}^{9}$中的所有组合可能,然后通过二进制表示
```cpp
vector<int> c;
void f(int num, int a, int b) {
    if (c.size() == a) {
        for (int i = 0; i < c.size();i++) {
            cout << c[i] << " ";
        }
        cout << endl;
        return;
    }
    if (num > b) return;
    c.push_back(num);
    f(num + 1, a, b);
    c.pop_back();
    f(num + 1, a, b);
}

int main() {
    f(1, 2, 5);
    return 0;
}
```

在$dfs$的实现过程中,**出口**是搜索到的元素的个数等于我们要求的数或者当前的数已经比全部的情况都要大时,输出并出来,**主体**是令当前的数不停加一,这样可以遍历到所有的情况,**回溯操作**是回溯到不用这个数字的加一,这样可以遍历出全部的数.
**<small>ps:从第三步回来了,我的这段代码在$m和$n很大的时候没有办法胜任这个任务,我还需要找一个更好的方法,留给明天吧</small>**

因为$C_{30}^{9}$可能的数达到了 $14307150$,所以用$C_{5}^{2}$代替,以下是输出结果$:$
>1 2 
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
>4 5


同时根据老师的要求我写了一段输出成二进制的格式的,暂时没有想通作用在哪里
```cpp
 void f(int num, int a, int b) {
    if (c.size() == a) {
        for (int i = 0; i < c.size(); i += 2) {
            bitset<4> bin(c[i]);
            cout << bin.to_string() << " ";
            if (i + 1 < c.size()){
            bitset<4> bin(c[i+1]);
            cout << bin.to_string() << " ";
            }
            cout << endl;
        }
        return;
    }
    if (num > b)
        return;
    c.push_back(num);
    f(num + 1, a, b);
    c.pop_back();
    f(num + 1, a, b);
}

int main() {
    f(1, 2, 5);
    return 0;
}
```
将bitset长度设为4来表示4个位,可以根据需要扩充.
##### 1.3 递归搜索
- 通过$dfs$,我们可以得到所有的可能的情况,然后我们可以通过这个情况来计算出每种情况的和,然后判断是否是$21$位数而且相等,如果是的话就输出

  ### 二.总结
    - 今天无法ac这道题了,我学会了高精度的书写,并且尝试找到一种求解$C_{30}^{9}$的方法,但是这个方法在数据量很大的时候无法胜任,所以我还需要找到一个更好的方法,明天继续努力吧


# $6$月$25$日学习报告 
## 递归学习
今天为了做昨天的21位花朵数的dfs部分,我们学习了递归
**递归**是一种解决问题的方法,它把一个问题分解为越来越小的子问题,直到问题的规模小到可以被很简单的解决.
### 反转数组
```cpp
#include <bits/stdc++.h>
using namespace std;
void f(int *a,int n){
    if(n==0) return;
    f(a+1, n - 1);
    cout << a[0] << " ";
}
int main(){
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    f(a,10);
    return 0;
}
```
这是一个递归的例子,它的功能是输出一个数组的所有元素,但是我们可以看到,它的递归部分是`f(a+1, n - 1);`这一句,它把问题的规模缩小了,这样就可以递归的调用自己,直到问题的规模缩小到0,这样就可以输出数组的所有元素了.
### 斐波那契数列
```cpp
#include <bits/stdc++.h>
using namespace std;
int fib(int n,int a,int b){
    if(n==0) return a;
    if(n==1) return b;
    return fib(n-1,b,a+b);

}
int main(){
    cout << fib(40, 0, 1);
    return 0;
}
```
在斐波那契数列中,传入的三个参数$n$是第几个数,而$a$和$b$是前两个数,通过让$a=b$并且在$b$上加上$a$的值,就可以得到下一个数,这样就可以递归的调用自己,直到$n=0$或者$n=1$时返回$a$或者$b$.
### 买票上车
题目描述：现有m个有0.5元的人，n个有1元的人需要上公交车，已知公交车费0.5元，司机可以找零，但司机目前没有零钱。问：有几种上车方案可以让司机为乘客找零？
>输入样例：3  2
输出样例：5
```cpp
#include <bits/stdc++.h>
using namespace std;
int f(int w,int y){
   if(w<y) return 0;
   if(y==0) return 1;
   return f(w-1,y)+f(w,y-1);
}
int main(){
    cout<<f(18,18);
    return 0;
}
```
紧接着是一个公交车问题,这个问题是这样的,有一个公交车,最开始没有零钱,票价是$5$毛钱,上来的顾客会给$5$毛钱和$1$元钱,如果是一元钱,公交车需要找还五毛钱,如果公交车没有多余的钱找零,那么这个方法就不是一个合理的方法,找出所有合理的方法一共有多少种.
通过递归的方法,我们传入的是付五毛钱和付一块钱的人的数量,如果付五毛钱的人的数量小于付一块钱的人的数量,那么这个方法就不是一个合理的方法,如果付一块钱的人的数量为$0$,那么这个方法就一定是一个合理的方法,这样就可以递归的调用自己,然后将下一位是付五毛钱的情况和下一位是付一块钱的情况相加,在下一层循环时继续重复此操作,就可以实现这个找到所有合理的方法了.
### 分苹果
题目描述：现有m个苹果，以及n个盘子，将苹果放在盘子里（盘子可以不全有苹果），问：有几种方案？
>样例：6  3
输出：7
```cpp
#include <bits/stdc++.h>
using namespace std;
// 提前声名
int f(int m, int n);
int g(int m, int n) {
    if (m < n)
        return 0;
    if (m == n)
        return 1;
    if (n == 1)
        return 1;
    return f(m - n, n);
}
int f(int m, int n) {
    if (n == 1)
        return 1;
    if (m == 1)
        return 1;
    if (n > m)
        return f(m, m);
    int sum = 0, i;
    for (int i = 1; i <= n; i++)
        sum += g(m, i);
    return sum;
}
int main() {
    cout<<f(6, 3);
    return 0;
}
```
有$m$个苹果,有$n$个盘子,每个盘子可能没有苹果,求有多少种方法,通过一个函数套函数的方法来解决,在`f`函数中代表的是盘子中没有苹果的情况,如果只有一个盘子或者一个苹果,返回一种情况,如果盘子的数量大于苹果的数量,那么就返回`f(m,m)`,代表无论有多少个盘子都是m个苹果放入m的盘子的情况,然后对剩下的苹果进行累加,累加时调用g函数,`g`函数代表 必须至少有一个,在`g`函数中,在处理边界后,把每个盘子都放入一个苹果,然后看作都没有放置苹果,再把就能把剩下的苹果放入`f`函数中继续递归
- 这种函数套函数我以前没有遇到过,感觉十分的神奇,同时理解起来也有点复杂,~~我觉得我很难自己写的出这种左脚踩右脚的写法~~(bushi)
 ### 汉诺塔
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  void  f(int n,char a ,char b , char c){
    if(n<=0) return;
    f(n - 1, a, c, b);
    cout<<a<<"->"<<c<<endl;
    f(n - 1, b, a, c);
    }
    int main(){
    f(3,'A','B','C');
    return 0;
   } 
  ```
  汉诺塔是一个经典的递归问题,通过递归的方法,我们可以把$n-1$个盘子从$A$柱子移动到$B$柱子,然后把第$n$个盘子从$A$柱子移动到$C$柱子,最后把$n-1$个盘子从$B$柱子移动到$C$柱子,这样就完成了整个汉诺塔的移动,这道题的关键我觉得在于`f(n - 1, b, a, c);`这里对递归函数的回溯,这样可以保持状态逻辑合理地延续下去.
  ### 小结
  对于递归,最重要的就是对于边界的处理,我们需要优先给我们的递归函数定义一个合理的出口,一个合理的出口才能保证我们的递归能够执行完毕,不然就会陷入无限的死循环中或者爆栈结束程序,在书写递归函数时,我们要把这个递归当作一个黑盒,只需要知道这个递归函数的功能,不需要知道这个递归函数是怎么实现的,这样就可以避免递归函数的逻辑错误,我觉得怎么读这个函数读的通顺是最关键的问题,把这个递归读作功能,然后接着往下写的时候把此递归部分看作最后一步,在函数后给它一个结尾,就能成功的写出一个递归函数了!

___
  ## 张老师的生日 
  #### (<small>博弈论或者离散数学?</small>)
**题目描述**
小明和小强都是张老师的学生，张老师的生日是M月N日，2人都知道张老师的生日是下列10组中的一天：

>3月4日 3月5日 3月8日
6月4日 6月7日
9月1日 9月5日
12月1日 12月2日 12月8日
张老师将M值告诉了小明，将N值告诉了小强，张老师问他们知道他的生日是哪一天吗？
小明说：如果我不知道的话，小强肯定不知道
小强说：本来我也不知道，但是现在我知道了
小明说：哦，那我也知道了
>据上面信息，推断出张老师的生日是哪一天？

- 通过小明说的第一句话,我们可以推断出小强不可能是 2和 5 否则小明无法断定小强一定不知道,所以小明一定不是12月和6月
- 小强又说,本来不知道,现在知道了,说明在小强的视角里,它可以选择的日期的相同日期和所在月一定无法大于3,不然无法达成小强本来不知道,现在又能确定,所以小强一定不是8日
- 最后小明说,我也知道了,同理说明小明也一定不能有三个同月份的选项,否则也无法直接判断出来,所以小明一定不是3月和6月
- 最后根据汇总的情报,小明一定不是3月和6月和12月,小强一定不是2日7日5日
- 所以张老师的生日是9月1日


___


  ## DFS与BFS
  接着是DFS与BFS,这俩真的是一个老生常谈的问题了,dfs使用的数据结构是栈,而bfs是队列.通过二叉树的先序遍历与后序遍历可以很形象的理解这个问题,对于dfs,就是先序遍历,而bfs就是后序遍历,也就是dfs先从"祖宗"杀起,而bfs是从"孙子"杀起,这样就可以很形象的理解这个问题了.dfs的先序遍历是中,左,右,而bfs的后序遍历是左,右,中.
  ### 经典例题
  `dfs`的经典例题就是N皇后了,这里以洛谷上的[P1219 [USACO1.5] 八皇后 Checker Challenge](https://www.luogu.com.cn/problem/P1219)为例
  ```cpp
  #include <bits/stdc++.h>
using namespace std;
int a[20][20] = {0};
bool test(int n, int m, int i) {
    int j;
    for (j = 0; j < m; j++) {
        if (a[j][i] == 1 || m + i - j < n && a[j][m + i - j] == 1 ||
            j + i - m >= 0 && a[j][j + i - m] == 1) {
            return false;
        }
    }
    return true;
}
int cnt = 0;
void hh1(int n, int m) {
    if (m == n) {
        cnt++;
        if(cnt<=3){
        int i, j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (a[i][j] == 1) {
                    cout << j+1 << " ";
                }
            }
        }
        cout << endl;
        }
        return;
    }
    int i;
    for (i = 0; i < n; i++) {
        if (test(n, m, i)) {
            a[m][i] = 1;
            hh1(n, m + 1);
            a[m][i] = 0;
        }
    }
}
void hh(int n) { hh1(n, 0); }
int main() {
    int _;
    cin >> _;
    hh(_);
    cout << cnt;
    return 0;
}
  ```
这是一个基础的做法,以二维数组来做,我们可以把它优化成一个一维数组来做;
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[20]={0};
int count = 0;
bool test(int n, int m, int i) {
    int j;
    for (j = 0; j < m; j++) {
        if (a[j]==i||a[j]==m+i-j||a[j]==j+i-m) {
            return false;
        }
    }
    return true;
}
void hh1(int n, int m) {
    if (m == n) {
        int i, j;
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if(a[i]==j) cout << "1 ";
                else cout << "0 ";  
            }
            cout << endl;
        }
        // cout << endl;
        ++::count;
        return;
    }
    int i;
    for (i = 0; i < n; i++) {
        if (test(n , m, i)) {
            a[m]=i;
            hh1(n, m + 1);
            //a[m][i] = 0;
        }
    }
}
void hh(int n) {
    int a[n];
    memset(a, 0, sizeof(int)*n);
    int count = 0;
    hh1(n, 0);
}
int main() {
    int _;
    cin >> _;
    hh(_);
    cout << ::count;
    return 0;
}
```
一维数组便优化好了,它是通过一个一维数组来存储皇后的位置,然后与y进行比较,如果在同一行或者同一列或者同一斜线上,那么就返回false,这样就可以很好的解决这个问题了.
**一维数组省去了回溯的操作,因为我们直接让`a[m]=i了`**
## 课后作业
### 1.用栈来解决N皇后问题
```cpp
#include <bits/stdc++.h>
using namespace std;

struct State {
    int x, y;
    int a[20][20];
};

int cnt = 0;

bool check(int a[20][20], int n, int x, int y) {
    for (int i = 0; i < x; i++) {
        if (a[i][y] == 1 || (y - x + i >= 0 && a[i][y - x + i] == 1) ||
            (y + x - i < n && a[i][y + x - i] == 1)) {
            return false;
        }
    }
    return true;
}

void f(int n) {
    stack<State> s;
    State ini = {0, 0, {}};
    s.push(ini);

    while (!s.empty()) {
        State cur = s.top();
        s.pop();

        if (cur.x == n) {
            cnt++;
            continue;
        }

        for (int y = 0; y < n; y++) {
            if (check(cur.a, n, cur.x, y)) {
                State state = cur;
                state.a[cur.x][y] = 1;
                state.x++;
                s.push(state);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    f(n);
    cout << cnt;
    return 0;
}
```
我们用结构体来表示处理的行列和棋盘目前的状态,对棋盘进行深搜,每次不停在栈中取堆顶,然后使用长度作为出口,但是在主体中我们不用递归的方式,而是用栈,我们在循环后检查是否满足边界条件,满足的话就把当前的棋盘状态压入栈,然后继续此操作,参考一维数组的方式这里就不用再进行回溯操作了,因为我们一直压入的都是当前的状态.
### 2.高IQ过河问题
[高IQ过河问题](https://www.4399.com/flash/252_1.htm)
#### 题目描述
`有一家六口人，包括爸爸、妈妈、两个女儿及两个儿子在旅行途中迷了路，还不幸遇上了一个逃狱的犯人，幸好犯人让一个也在旅行的警察逮捕，一家六口才得以保住性命。可是，在荒郊野外，手机接受不灵，他们都不能与外界联络，连警察也不能找到支援，他们只有通过一条河流方能回家，能帮帮他们么？`
玩家的任务是，帮助这些人渡过河，交通工具只有一艘小船。只有爸爸、妈妈以及警察能控制小船，此外，不论成人或是小孩，小船每次最多只能搭乘二人。在渡河期间，玩家还要防止以下三种情况发生：
1、当警察与犯人分开时，犯人会伤害一家六口。
2、当爸爸看见妈妈离开女儿时，爸爸便会教训女儿。
3、当妈妈看见爸爸离开儿子时，妈妈便会教训儿子。
#### 解题思路
正确的解法之一是:先是警察和犯人过去，警察回来，警察再带一个男孩过去，把犯人带回来，爸爸再带一个男孩过去，爸爸回来，爸爸妈妈过去，妈妈回来，警察犯人过去，爸爸回来，爸爸妈妈过去，妈妈回来，妈妈带一个女儿过去，警察犯人回来，警察带一个女儿去，再回来，把犯人带回来.
递归找出这种正确的解法

我需要定一些边界条件,在我的想法中,首先犯人必须一个人在一边或者跟警察在一起,不然就返回 return;
然后是如果爸爸和某个女儿在一边&&妈妈不在,那么就返回return;如果妈妈跟某个儿子在一边&&爸爸不在,那么就返回return;如果要移动的不是一个大人和一个小孩,那么就返回return;
我们可以开一个数组表示两岸,0表示这个人没过河了,然后一艘船的bool类型来代表船在哪一边
```cpp
#include <bits/stdc++.h>
using namespace std;
//0 小偷 1 警察 2 爸爸 3 妈妈 4 女儿1 5 儿子1 6 女儿2  7儿子2
vector<int> a(8, 0);
bool boat = 0;
bool check(int fir, int sec){
    if(a[0]^a[1]){
        for(int i = 2; i < 8; i++){
            if(a[i] == a[0]){
                return 0;
            }
        }
    }
    if(a[2]==a[4]||a[2]==a[6]){
        if(a[2]!=a[3])
        return 0;
    }
    if(a[3]==a[5]||a[3]==a[7]){
        if(a[3]!=a[2])
        return 0;
    }
    if(sec-fir>2){
        if(a[0]!=a[1]){
            return 0;
        }
    }
}
int main(){
    return 0;
}
```


今天只能推断到这里了,明天继续写

# 6月26日学习报告
# 今天最重要的事情:
# 今天最重要的事情:
# 今天最重要的事情:
#  AC了!AC了!21位花朵数终于AC了!

![AC截图](https://img.picui.cn/free/2024/06/26/667baf2e5e3ee.png)

下面开始今天的报告吧

___


## 高IQ过河
 ### 题目描述
`有一家六口人，包括爸爸、妈妈、两个女儿及两个儿子在旅行途中迷了路，还不幸遇上了一个逃狱的犯人，幸好犯人让一个也在旅行的警察逮捕，一家六口才得以保住性命。可是，在荒郊野外，手机接受不灵，他们都不能与外界联络，连警察也不能找到支援，他们只有通过一条河流方能回家，能帮帮他们么？`
玩家的任务是，帮助这些人渡过河，交通工具只有一艘小船。只有爸爸、妈妈以及警察能控制小船，此外，不论成人或是小孩，小船每次最多只能搭乘二人。在渡河期间，玩家还要防止以下三种情况发生：
1、当警察与犯人分开时，犯人会伤害一家六口。
2、当爸爸看见妈妈离开女儿时，爸爸便会教训女儿。
3、当妈妈看见爸爸离开儿子时，妈妈便会教训儿子。
### 解题思路
- 接着昨天的思路走,我们先枚举所有的人,将他们定为2的0次幂到2的8次幂,这样在每种组合的情况下,都有固定的唯一解表示谁与谁相加.
-  然后我们写一个布尔类型的函数判断x是否包含y,也就是在岸上有没有y表示的几个人
   这里的判断使用到了按位与,只要x的二进制按位与y的全部都相等,就表示y表示的几个人都在x中,也就是都在岸上.
-  然后我们写了一个函数判断是否满足游戏规则,也就是:
`1、当警察与犯人分开时，犯人会伤害一家六口。`
`2、当爸爸看见妈妈离开女儿时，爸爸便会教训女儿。`
`3、当妈妈看见爸爸离开儿子时，妈妈便会教训儿子。`
### 代码分析
- 接着进行深搜,因为我们只需要获取一种情况,所以给出口加一个开关,让它找到一种情况就结束程序
- 出口我们定为当x==0的时候,也就是岸的出发点没有人的时候,就进行输出并结束程序
- 然后就是我觉得最神奇的地方了,我们造一个数组,存放每组组合可能的情况,对他们进行或运算,也就是相加,因为数组是静态的,所以传参时不会导致它更新或者乱跑
- 接下来我们对船靠哪边的岸分别进行讨论,开一个512大小的数组,0-255代表船靠近出发点的时候每种情况有没有被用过,256-511代表河对岸时的状态,通过在循环中更新这个数组,就可以避免重复进行相同无意义的操作
- 当船在出发点的时候,不都在出发点的组合不选,组合上船后不合理的组合不选,组合下船后不合理的组合不选,组合过河的方式被用过的不选,然后递归将步骤数累加,减掉过去的组合,继续递归
- 当船在对岸的时候,与船在出发点的时候处理方式相同
- 然后我们就会得到这样一串数:
  >192 128 144 192 40 32 36 4 192 32 36 4 6 192 129 128 192 
  通过将每个数组分解成唯一的两个数相加,代表对哪两个人进行上船过河,最后就能模拟出答案来了

  [![pkyktdx.png](https://s21.ax1x.com/2024/06/26/pkyktdx.png)](https://imgse.com/i/pkyktdx)
### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
// jc  =128, xt=64,bb=32,dr=16,er=8,mm=4,dn=2,en=1
enum { JC = 128, XT = 64, BB = 32, DR = 16, ER = 8, MM = 4, DN = 2, EN = 1 };
// 测x是否包含y
bool f1(int x, int y) { return (x & y) == y; }
// 判断x是否合理
bool f2(int x) {
    if (!f1(x, JC) && x > 64) return false;
    if (!f1(x, BB) && f1(x, MM) && (f1(x, DR) || f1(x, ER))) return false;
    if (f1(x, BB) && !f1(x, MM) && (f1(x, DN) || f1(x, EN)))return false;
    return true;
}
void f(int x, int *result, int step, bool &finished) {
    if (finished) return;
    if (x == 0) {
        int i;
        for (i = 0; i < step; i++) {
            cout << result[i] << " ";
        }
        finished = true;
        return;
    }
    static int a[15] = {
        JC | XT, JC | BB, JC | DR, JC | ER, JC | MM,JC | DN, JC | EN, JC,
        BB | DR, BB | ER,BB | MM, BB, 
        MM | DN, MM | EN, MM};
    int i;
    static bool flag[512];
    for ( i = 0; i < 15; i++)
        if (step % 2 == 0) {
            if (!f1(x, a[i])) continue;
            if (!f2(x - a[i])) continue;
            if (!f2(255 - x + a[i])) continue;
            if (flag[x - a[i]]) continue;
            flag[x - a[i]] = 1;
            result[step] = a[i];
            f(x - a[i], result, step + 1, finished);
        } else {
            if (!f1(255-x, a[i])) continue;
            if (!f2(255-x - a[i])) continue;
            if (!f2(x + a[i]))  continue;
            if (flag[x + a[i]+256])continue;                                                                    
            flag[x + a[i]+256] = 1;
            result[step] = a[i];
            f(x + a[i], result, step + 1, finished);
        }
}

int main() {
    bool finished = false;
    int result[200];
    f(255, result, 0, finished);
    return 0;
}
```
## 方格分割
[原题链接](https://www.lanqiao.cn/problems/644/learning/?page=1&first_category_id=1&name=%E6%96%B9%E6%A0%BC)
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

6x6的方格，沿着格子的边线剪开成两部分。 要求这两部分的形状完全相同。

如下就是三种可行的分割法。

![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210317-1615964222859)

![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210317-1615964217192)

![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210317-1615964210676)

试计算： 包括这 $3$ 种分法在内，一共有多少种不同的分割方法。 注意：旋转对称的属于同一种分割法。

>运行限制
最大运行时间：1s
最大运行内存: 128M
### 题目分析 
我们通过计算矩阵上的点,从中间开始,往上,下,左,右四个方向分别搜索,如果在点往一边走时,另一边对称点相应的也要进行描图,如果搜到了边界,那么这就是一种情况,计算出所有的情况后除以4,因为 `旋转对称的属于同一种分割法` 所一我们在上,下,左,右四个方向遍历的情况其实是4倍
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
int mp[7][7]={0};
int cnt = 0;
void dfs(int x,int y){
  if(x==0||y==0||x==6||y==6){
      cnt++;
      return;
  }
  for (int i = 0; i < 4;i++){
      int endx=x+dx[i], endy=y+dy[i];
      if (!mp[endx] [endy]) {
          mp[endx][endy] = 1;
          mp[6 - endx][6 - endy] = 1;
          dfs(endx, endy);
          mp[endx][endy] = 0;
          mp[6 - endx][6 - endy] = 0;
      }
  }
}
int main(){
    mp[3][3] = 1;
    dfs(3, 3);
    cout << cnt/4 << endl;
    return 0;
}
```
我们最后找到了答案是509,成功AC

## 再战21位花朵数
<font color=red><b>第一天做这道题我理解错了组合数的意思,我错误的把它理解为了代表左边一堆的数量,实际上这个组合数的情况代表着坐标,而坐标之间的差-1就是每个数有几个</b></font>

首先是找组合数,代码在第一次其实便已实现,我对它进行了一些修改,我将传入的值改为了begin,并且把递归放入了循环当种,这样就能递归遍历出所有的情况了
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> c;
void f(int begin,int n,int m){
 if(c.size()==n){
     for (int i = 0; i < n;i++){
            cout << c[i] << " ";
     }
     cout << endl;
     return;
 }
 for (int i = begin; i < m;i++){
     c.push_back(i);
     f(i + 1, n, m);
     c.pop_back();
 }
}
int main(){
    int n, m;
    cin>>n>>m;
    f(0,n, m);
    return 0;
}
```
 接着就是把组合数返回成每个数字用了几次,然后去检查这个数各位数21次幂之和是否等于这个数本身,就可以输出了
 ```cpp
 Int lst[10] = {{"0"},
               {"1"},
               {"2097152"},
               {"10460353203"},
               {"4398046511104"},
               {"476837158203125"},
               {"21936950640377856"},
               {"558545864083284007"},
               {"9223372036854775808"},
               {"109418989131512359209"}};
vector<int> c;
vector<int> jishu(10);
bool check(string s){
    if(s.size()!=21)  return 0;
    vector<int> jishu2(10, 0);
    for (int i = 0; i < s.size(); i++) {
        jishu2[s[i] - '0']++;
    }
    for (int i = 0; i < 10; i++) {
        if(jishu[i]!=jishu2[i])
            return 0;
    }
    return 1;
}
void f(int begin, int n, int m) {
    if (c.size() == n) {
        Int sum=0;
        vector<int> moni;
        moni.push_back(0);
        for (int i = 0; i < c.size(); i++) {
            moni.push_back(c[i]);
        }
        int j = 0,summing=0;
        for (int i = 1;i<moni.size();i++){
            int d = 1;
            if(i==1)d=0;
            jishu[j]=moni[i]-moni[i-1]-d;
            j++;
        }
        for (int i = 0; i < 9;i++){
            summing += jishu[i];
        }
            jishu[9] = 21 - summing;
        for (int i = 0;i<10;i++){
            sum+=lst[i]*jishu[i];
        }
        string s=sum.to_string();
        if(check(s)){
            cout << s << endl;
        }
        return;
    }
    for (int i = begin; i < m; i++) {
        c.push_back(i);
        f(i + 1, n, m);
        c.pop_back();
    }
}
 ```
对于这部分的实现有几个点卡了我一段时间
- 首先就是对moni数组的处理,我在处理它时先插入了一个0,方便计算第一位数的坐标有多少个,但是当第一位的坐标是0的时候,我的jishu就会变成-1,在检查后我发现第一个坐标不能让它-1,从而解决了这个问题. `jishu[j]=moni[i]-moni[i-1]-d;`
- 其次就是 ` jishu[9] = 21 - summing;` 这一块,在很长的一段时间里,我没有意识到9的个数没有被计算,因为隔板只有九个,导致了我数组无法与正确的数组正确的比较大小,始终无法输出.
- 对于check函数中位数和每位数字的统计的处理,我在结构体中增添了一个to_string的重载,先将大整型化作字符串,再进行处理.
  #### 编码实现

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  struct Int {
    int arr[6];
    bool yc;
    Int(int n = 0) {
        memset(arr, 0, sizeof(int) * 6); 
        yc = 0;                         
        int i = 0;
        while (n) {
            arr[i++] = n % 10000;
            n /= 10000;
        }
    }
    Int(string s) {
  
        memset(arr, 0, sizeof(int) * 6);
        yc = 0;
        int i = 0;
        int len = s.size();
        len = len <= 21 ? len - 1 : 20;
        int tmp;
        for (; len >= 0; --len) {
            if (i % 4 == 0)
                tmp = 0;
            tmp += (s[len] - '0') * pow(10, i % 4);
            if (i % 4 == 3 || len == 0) {
                arr[i / 4] = tmp;
            }
            ++i;
        }
    }
    void display() const {
        int i;
        bool flag = 0;
        for (i = 5; i >= 1; i--) {
            if (flag || arr[i]) {
                if (flag == 0)
                    printf("%d", arr[i]);
                else
                    printf("%04d", arr[i]);
                flag = 1;
            }
        }
        if (flag)
            printf("%04d", arr[i]);
        else
            printf("%d", arr[i]);
    }
    bool operator<(const Int &b) const {
        int i;
        for (int i = 5; i >= 0; --i)
            if (this->arr[i] < b.arr[i])
                return 1;
            else if (b.arr[i] < this->arr[i])
                return 0;
        return 0;
    }
    bool operator>(const Int &b) const { return b < *this; }
    bool operator<=(const Int &b) const { return !(b < *this); }
    bool operator>=(const Int &b) const { return !(b > *this); }
    bool operator==(const Int &b) const { return !(*this < b) && !(b < *this); }
    Int &operator+=(const Int &b) {
        int i;
        int jin = 0;
        for (i = 0; i < 6; i++) {
            int tmp = arr[i] + b.arr[i] + jin;
            arr[i] = tmp % 10000;
            jin = tmp / 10000;
        }
        if (jin)
            yc = 1;
        return *this;
    }
    Int operator+(const Int &b) const {
        Int tmp = *this;
        return tmp += b;
    }
    Int &operator*=(int b) {
        int i;
        int jin = 0;
        for (int i = 0; i < 6; ++i) {
            int tmp = arr[i] * b + jin;
            arr[i] = tmp % 10000;
            jin = tmp / 10000;
        }
        if (jin)
            yc = 1;
        return *this;
    }
    Int operator*(int b) {
        Int tmp = *this;
        return tmp *= b;
    }
    string to_string() const {
        ostringstream oss;
        bool isLeading = true;
        for (int i = 5; i >= 0; --i) {
            if (arr[i] != 0 || !isLeading) {
                if (isLeading) {
                    oss << arr[i];
                    isLeading = false;
                } else {
                    oss << setw(4) << setfill('0') << arr[i];
                }
            }
        }
        string result = oss.str();
        if (result.empty())
            return "0";
        return result;
    }
   };
   Int lst[10] = {
               {"0"},
               {"1"},
               {"2097152"},
               {"10460353203"},
               {"4398046511104"},
               {"476837158203125"},
               {"21936950640377856"},
               {"558545864083284007"},
               {"9223372036854775808"},
               {"109418989131512359209"}};
    vector<int> c;
    vector<int> jishu(10);
    bool check(string s){
    if(s.size()!=21)  return 0;
    vector<int> jishu2(10, 0);
    for (int i = 0; i < s.size(); i++) {
        jishu2[s[i] - '0']++;
    }
    for (int i = 0; i < 10; i++) {
        if(jishu[i]!=jishu2[i])
            return 0;
    }
    return 1;
    }
    void f(int begin, int n, int m) {
    if (c.size() == n) {
        Int sum=0;
        vector<int> moni;
        moni.push_back(0);
        for (int i = 0; i < c.size(); i++) {
            moni.push_back(c[i]);
        }
        int j = 0,summing=0;
        for (int i = 1;i<moni.size();i++){
            int d = 1;
            if(i==1)d=0;
            jishu[j]=moni[i]-moni[i-1]-d;
            j++;
        }
        for (int i = 0; i < 9;i++){
            summing += jishu[i];
        }
            jishu[9] = 21 - summing;
        for (int i = 0;i<10;i++){
            sum+=lst[i]*jishu[i];
        }
        string s=sum.to_string();
        if(check(s)){
            cout << s << endl;
        }
        return;
    }
    for (int i = begin; i < m; i++) {
        c.push_back(i);
        f(i + 1, n, m);
        c.pop_back();
    }
    }
  
    int main() {
    f(0,9,30);
    return 0;
    }   
  ```

经历了三天的努力,我终于拿下了 $21$ 位花朵数!
在课堂上,老师使用了一种树形的方式去 $dfs$ 这个 $21$ 位花朵数,还没有完全理解透彻,通过将$C_{5}^{3}$分割成$C_{4}^{2}$和$C_{3}^{2}$,然后再分别分割成$C_{3}^{1}$和$C_{2}^{1}$,最后分割成 $C_{2}^{1}$ 和 $C_{1}^{1}$ ,像这样搜索下去,就能得到所有的情况,然后再通过dfs的方式去遍历所有的情况,这样就能得到所有的情况了,这种方法我觉得很巧妙,但是我还没有完全理解透彻,希望以后能够理解透彻.
```cpp
void f1(int m, int n, bool *str, int M,bool*Str) {
   int j;
   if(m<n) return;
    if(n==0){
        for(j=0;j<M;j++)
        cout<<str[j];
        cout<<endl;
        return;
    }
    for (j = 0; j < m - n + 1;j++){
        str[j] = 1;
        f1(m-1-j,n-1,str,M,Str);
        str[j] = 0;
    }
}
void f(int m, int n) {
    bool str[m];
    memset(str, 0, sizeof(bool) * m);
    f1(m, n, str, m,str);
    }
void C1(int *in, int *out, int m, int n, int N) {
    int j;
for(j=0;j<m;j++)

}
```

# 6月27日学习报告
## 老师的找数问题
### 题目：

有两个大于1小于100的自然数x,y，老师告诉小明两个数的和，告诉小强两个数的积。已知小明和小强足够聪明。

下面是两个人的对话：

>小强：我不知道这两个数是多少,你肯定也不知道
小明：我本来不知道,但你这么我说,我就不知道了。
小强：那现在我知道了。

问这两个数是多少？

#### 题目分析
首先甲不可能是偶数,根据哥德巴赫猜想,每个偶数都能拆成两个质数之和,两个质数的积一定唯一,那么甲每一个按和拆分组成的乘积都要有两种或两种以上的拆分方式.
将满足条件的数放入map中,观察一下打表的的结果:
![Snipaste_2024-06-27_14-21-41.png](https://img.picui.cn/free/2024/06/27/667d04be562f1.png)
观察一下这个map,如果这些加数因子的乘积不唯一,那么这个加数就不是我们要选择的数,因为小明可以通过小强得出答案,唯一的乘积就是小强拿到的两数之积,唯一的加数就是小明拿到的两数之和.
#### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int f2(int n) {
    int count = 0;
    int i = 2, j;
    int sq = sqrt(n);
    for (; i <= sq; i++) {
        if (n % i == 0) {
            j = n / i;
            if (j <= 99 && i != j)
                count++;
        }
    }
    return count;
}
void f3() {
    int i, j, k;
    map<int, vector<int>> m;
    for (i = 5; i <= 197; i += 2) {
        for (j = 2; j <= i / 2; j++) {
            k = i - j;
            if (k <= 99 && k != j) {
                int count = f2(k * j);
                if (count == 1) {
                    goto L;
                }
            }
        }

        for (int u = 2; u <= i / 2; u++) {
            m[i].push_back((i - u) * u);
        }
    L:;
    }
    map<int, int> m1;
    for (auto it = m.begin(); it != m.end(); it++)
        for (i = 0; i < it->second.size(); i++)
            m1[it->second[i]]++;

    set<int> s;
    for (auto it = m1.begin(); it != m1.end(); it++)
        if (it->second == 1)
            s.insert(it->first);

    int he, cheng;
    for (auto it = m.begin(); it != m.end(); it++) {
        int cnt = 0;
        vector<int> v;
        for (i = 0; i < it->second.size(); i++) {
            if (s.find(it->second[i]) != s.end()) {
                cnt++;
                v.push_back(it->second[i]);
            }
        }
        if (cnt == 1) {
            he = it->first;

            cheng = v[0];
        }
        v.clear();
    }
    for (int i = 2; i <= 99; i++) {
        for (int j = 2; j <= 99; j++) {
            if (i + j == he && i * j == cheng) {
                cout << i << " " << j << endl;
                return;
            }
        }
    }
}

int main() {
    f3();
    return 0;
}
```
####   运行结果
> 4 13

## 平方末尾
[原题链接](https://www.lanqiao.cn/problems/654/learning/?page=2&first_category_id=1&name=%E6%96%B9)
### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。

能够表示为某个整数的平方的数字称为“平方数”

虽然无法立即说出某个数是平方数，但经常可以断定某个数不是平方数。 因为平方数的末位只可能是：[0,1,4,5,6,9]这 6 个数字中的某个。 所以，4325435332 必然不是平方数。
如果给你一个 2 位或 2 位以上的数字，你能根据末位的两位来断定它不是平方数吗？
请计算一下，一个 2 位以上的平方数的最后两位有多少种可能性？

运行限制
最大运行时间：1s
最大运行内存: 128M

### 题目分析
我们可以直接先把1-100的平方数打表,然后取出每个数的后两位,放入set中,最后输出set的大小即可.
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    vector<int> a(100,0);set<int> se;
    for(int i=0;i<100;i++){
        a[i]=pow(i,2);
    }
    for(int i=4;i<100;i++){
        string s=to_string(a[i]);
        se.insert(stoi(s.substr(s.size()-2,2)));
    }
    cout<<se.size();

    return 0;
}
```
## 反幻方
[原题链接](https://www.lanqiao.cn/problems/655/learning/?page=2&first_category_id=1&name=%E6%96%B9)
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

我国古籍很早就记载着

>2 9 4
7 5 3
6 1 8

这是一个三阶幻方。每行每列以及对角线上的数字相加都相等。

下面考虑一个相反的问题。 可不可以用 1 ~ 9的数字填入九宫格。 使得：每行每列每个对角线上的数字和都互不相等呢？

这应该能做到。 比如：

>9 1 2
8 4 3
7 5 6

你的任务是搜索所有的三阶反幻方。并统计出一共有多少种。旋转或镜像算同一种。

比如：

>9 1 2
>8 4 3
>7 5 6
>
>7 8 9
>5 4 1
>6 3 2
>
>2 1 9
>3 4 8
>6 5 7

都算作同一种情况。

请问三阶反幻方一共多少种？

运行限制
- 最大运行时间：1s
- 最大运行内存: 128M

### 题目分析
我们通过dfs将元素不停查询,找到每一种可能的排列方式,然后通过对行,列 ,对角线的和 存入set判断有没有重复来检查啊是否是反幻方.
最终的结果需要除以8,因为旋转和镜像算一种.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int matrix[]={1,2,3,4,5,6,7,8,9};
int mp[9]={0};
int cnt = 0;
bool check() {
    set<int> se;
    se.insert(mp[0] + mp[1] + mp[2]);
    se.insert(mp[3] + mp[4] + mp[5]);
    se.insert(mp[6] + mp[7] + mp[8]);
    se.insert(mp[0] + mp[3] + mp[6]);
    se.insert(mp[1] + mp[4] + mp[7]);
    se.insert(mp[2] + mp[5] + mp[8]);
    se.insert(mp[0] + mp[4] + mp[8]);
    se.insert(mp[2] + mp[4] + mp[6]);

    
    return se.size() == 8;
    }
void dfs(int step) {
    if(step==9){
        if(check()){
            cnt++;
        }
        return;
    }
    for (int i = 0; i <= 8; i++) {
        if(!mp[i]){
            mp[i] = matrix[step];
            dfs(step + 1);
            mp[i] = 0;
        }
    }
}
int main() {
    dfs(0);
    cout << cnt/8 << endl;
    return 0;
}
```
### 优化
这道题还有一个简单的写法,我们可以通过`next_permutation`函数来生成全排列来代替dfs.
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int count = 0;
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    do{
        vector<int> b(8);
        b[0] = a[0] + a[1] + a[2];
        b[1] = a[3] + a[4] + a[5];
        b[2] = a[6] + a[7] + a[8];
        b[3] = a[0] + a[3] + a[6];
        b[4] = a[1] + a[4] + a[7];
        b[5] = a[2] + a[5] + a[8];
        b[6] = a[0] + a[4] + a[8];
        b[7] = a[2] + a[4] + a[6];
        sort(b.begin(), b.end());
        b.erase(unique(b.begin(), b.end()), b.end());
        if(b.size() == 8){
            count++;
        }
    }while(next_permutation(a, a + 9));
    cout << count/8 << endl;
    return 0;
}
```
`next_permutation`函数是C++标准库中的一个函数,它可以生成一个序列的下一个排列,如果当前排列是最后一个排列,那么返回false,否则返回true.这个函数的时间复杂度是O(n),空间复杂度是O(1).它会直接改变数组的序列,我们只需要在while循环中直接使用数组进行我们想要达到的操作即可.

# 7月1日学习报告暨6月28日教师赛题解
## A.放麦子
### 题目描述

你一定听说过这个故事。国王对发明国际象棋的大臣很佩服，问他要什么报酬，大臣说：请在第 1个棋盘格放 1 粒麦子，在第 2 个棋盘格放 2 粒麦子，在第 3个棋盘格放 4粒麦子，在第 4个棋盘格放 8 粒麦子，......后一格的数字是前一格的两倍，直到放完所有棋盘格（国际象棋共有 64格）。 国王以为他只是想要一袋麦子而已，哈哈大笑。 当时的条件下无法准确计算，但估算结果令人吃惊：即使全世界都铺满麦子也不够用！ 请你借助计算机准确地计算，到底需要多少粒麦子

**输入**
>无

**输出**
>按要求输出答案
### 解题思路
这道题大的意思其实就是让我们求 $2^0+2^1+2^2+2^3+...+2^{63}$ 的值。这个数是一个等比数列的和，可以用等比数列的求和公式来求解。公式为：$S_n=a_1\frac{1-q^n}{1-q}$，其中 $S_n$ 是等比数列的和，$a_1$ 是首项，$q$ 是公比，$n$ 是项数。这里的首项$a_1=1$，公比 $q=2$，项数 $n=64$ ，所以 $S_{64}=1\cdot \frac{1-2^{64}}{1-2}=2^{64}-1$ 。所以答案就是 $2^{64}-1$。
**其实这道题很好想,我们需要求的是 $\sum_{n=0}^{63} 2^n$ ,在计算机的思想中, $\sum_{n=0}^{x} 2^n$ 其实就是二进制下的无数个 1,所以我们直接用上一位 $-1$ 就可以了。**
### 代码实现
```python
print((1<<64)-1)
```

## B.刘谦的魔术
### 题目描述
2024年央视春节联欢晚会上，刘谦表演了一个基于约瑟夫环问题的魔术。 魔术操作步骤如下： 1、 准备4张不同的扑克牌，随机打乱，即为ABCD； 2、 将4张扑克撕成两半，变成8张，排列为ABCDABCD； 3、 根据名字的长度n，循环n次：将最上面牌放到最下面。假设，n=6，此时，排列为CDABCDAB； 4、 将上面3张牌，放在最后1张牌和第1张（原第4张）之间，此时第1张和最后一张均为B，其他则任意次序，排列为BXXXXXXB； 5、 将第1张放在屁股下面，此时，屁股下为B，剩余排列为XXXXXXB； 6、 南北方人拿上面1或2张牌，随意插入到最后1张之前，排列仍为XXXXXXB； 7、 男生或女生扔掉上面1张或2张，这里以女生为例，排列为XXXXB； 8、 见证奇迹的时刻，循环7次：将最上面牌放到最下面，排列为XXBXX； 9、 好的留下来，将最上面牌放到最下面，排列为XBXXX； 10、 不好的丢出去，扔掉第1张牌，排列为BXXX； 11、 好的留下来，将最上面牌放到最下面，排列为XXXB； 12、 不好的丢出去，扔掉第1张牌，排列为XXB； 13、 好的留下来，将最上面牌放到最下面，排列为XBX； 14、 不好的丢出去，扔掉第1张牌，排列为BX； 15、 好的留下来，将最上面牌放到最下面，排列为XB； 16、 不好的丢出去，扔掉第1张牌，排列为B； 17、 此时，剩下的B和屁股下面的恰好是同一张牌。 假设，4张打乱后的扑克牌，恰好为JQKA。

### 输入
第一行是整数M，表示有M个问题。 接下来的M行，每行三个整数N、A、X，其中，N表示名字的长度，A是1或2表示南北方，X是1或2表示男女。

### 输出
每行一个数，与输入相对应的，剩下的那张牌对应的字符。

### 样例输入
>2
2 2 2
3 1 1

### 样例输出
>Q
K

### 解题思路
做这道题的时候,模拟扑克牌很像一个队列,所以我用队列来进行了逐步的模拟,我发现,当模拟到`4、 将上面3张牌，放在最后1张牌和第1张（原第4张）之间，此时第1张和最后一张均为B，其他则任意次序，排列为BXXXXXXB；`时,其实队列的头,也就是'B'其实就是我们要找的答案,所以到这里为止直接输出就可以了。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
string dic = "JQKAJQKA";
int main() {
    int m;
    cin >> m;
    while (m--) {
        queue<int> q;
        for (int i = 0; i < 8; i++) {
            q.push(i);
        }
        int n, a, x;
        cin >> n >> a >> x;
        for (int i = 0; i < n; i++) {
            int tmp = q.front();
            q.pop();
            q.push(tmp);
        }
        q.pop();
        q.pop();
        q.pop();
        cout << dic[q.front()] << endl;
    }
    return 0;
}
```
### 老师的代码版本
老师的代码更牛,直接对n+3取模,代表根据名字长度%4也就是四张牌后换掉三张的内一张,直接就可以得出答案了。
```cpp
int main() {
    char s[] = "JQKA";
    int m;
    scanf("%d", &m);
    while (m--) {
        int n, x, y;
        scanf("%d%d%d", &n, &x, &y);
        printf("%c\n", s[(n + 3) % 4]);
    }
}
```
## C.既约分数
### 题目描述
分子和分母的最大公约数为1的分数，被称为既约分数。例如，8/1、8/3、3/8等等，都是既约分数，请问分子和分母都在[1,2024]之间的既约分数有几个？

### 输入
>无

### 输出
> 按要求输出答案

### 解题思路
~~这道题其实就是求$1\leq x \leq 2024,1\leq y \leq 2024$的互质数的个数,这个数是一个莫比乌斯函数的值,莫比乌斯函数的定义是$\mu(n)=\begin{cases} 1 & \text{若} n=1 \\ (-1)^k & \text{若} n=p_1p_2p_3...p_k \\ 0 & \text{若} n \text{有平方数因子} \end{cases}$,所以我们可以直接用莫比乌斯函数的定义来求解这道题。~~
这是一道非常简单的题,因为数据小我们直接暴力就行, 8/3 3/8算两个,8/8算一个,代码如下:
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b);
    return a;
}
int main() {
    int count = 0;
    for (int i = 1; i <= 2024; i++) {
        for (int j = i; j <= 2024; j++) {
            if (gcd(i, j) == 1&&i!=j) {
                count+=2;
            }else if(gcd(i,j)==1&&i==j){
                count++;
        }
    }
    }
    cout<<count<<endl;
    return 0;
}
```

## D.退休次序
### 题目描述
假设男老师60岁退休，女老师55岁退休。院长想知道老师们的退休次序，请你为下面给出的身份证号码，根据退休的先后重新排序，存在同一天退休的情况时，请将身份证号码字典序小的放在前面
### 输入
第一行整数N，后面N行是N个身份证号码

### 输出
按要求的次序输出，每行一个身份证号码，以及该教师的退休日期，两项信息使用空格分隔

### 样例输入 
>2
211402197810030858
420503198307242348

### 样例输出 
>420503198307242348 20380724
211402197810030858 20381003

### 解题思路
这就是一道简单的结构体排序,我们用`substr`提取出他们退休的时间,然后按要求排序就好,身份证的倒数第2位代表了性别,~~但是这里写成s.size()-2不给过,写成[16]就过了,并不知道出了什么奇怪的bug~~,我现在知道我错哪了,不是s.size()-2是ss.size()-2,........................
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
struct teacher {
    string shenfenzheng, shijian;
};
bool cmp(teacher a, teacher b) {
    if (a.shijian != b.shijian) return a.shijian < b.shijian;
    return a.shenfenzheng < b.shenfenzheng;
}
int main() {
    int n;
    cin >> n;
    vector<teacher> s(n);
    for (int i = 0; i < n; i++) {
        string ss;
        cin >> ss;
        if (ss[s.size() - 1] == 'X')
            ss[s.size() - 1] = 0;
        string time = to_string(stoi(ss.substr(6, 4)) +
                                ((ss[16] - '0') % 2 == 0 ? 55 : 60));
        time += ss.substr(10, 4);
        s[i].shenfenzheng = ss;
        s[i].shijian = time;
    }
    sort(s.begin(), s.end(), cmp);
    for (int i = 0; i < s.size(); i++) {
        cout << s[i].shenfenzheng << " " << s[i].shijian << endl;
    }
    return 0;
}
```
## E.字符串年号
### 题目描述
小明用字母A对应数字1 ，B对应 2，以此类推，用Z对应26 。对于27以上的数字，小明用两位或更长位的字符串来对应，例如AA对应27，AB 对应28，AZ对应52，LQ对应329。

### 输入
一个1~10000之间的整数

### 输出
对应的字符串

### 样例输入
>2024

### 样例输出
>BYV

### 解题思路
这道题其实就是一个进制转换,比较特殊的是他的首位不是0而是A,所以我们在每次的短除的时候要先把这个数减一,然后再对26取模就是正确的转换了

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    string s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    int n;
    cin >> n;
    string ans = "";
    while (n) {
        n--;
        ans += s[n % 26];
        n /= 26;
    }
    reverse(ans.begin(), ans.end());
    cout << ans;
}
```
## F.汉字谜面
### 题目描述
汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。16点阵的字库把每个汉字看成是16×16个像素信息。并把这些信息记录在字节中。一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。 把每个字节转为二进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是：
    第 1 字节，第 2 字节
    第 3 字节，第 4 字节
    ....
    第 31 字节, 第 32 字节

这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。
题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求再编写程序输出答案。
这段信息是（一共 10 个汉字）：
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 

### 输入
无

### 输出
请输出相应答案

### 解题思路
我们只需要将输入的数转化为二进制,然后只取后8位输出就可以了,因为一行是16个像素,所以一个字节我们只要它的8个像素
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    // for (int i = 0; i < 10;i++){
    //     for (int j = 0; j < 16;j++){
    //         for (int k = 0; k < 2;k++){
    //             int a;
    //             cin >> a;
    //             cout<<bitset<8>(a)<<" ";
    //         }
    //         cout << endl;
    //     }
    //     cout << endl << endl;
    // }
    unsigned long long ans = 1;
    for (int i = 0; i < 9;i++){
        ans *= 9;
    }
    cout << ans << endl;
    return 0;
}
```
注释内的部分可以打印出来十个16*16的01串,我们画出来可以看到说的是`九的九次方等于多少?` 输出即可;

## G.A和B
### 题目描述
有两个正整数A和B，A小于B。已知A和B的和X，以及A和B的最小公倍数Y，问A和B是多少？

**输入**
一个正整数N（N小于50），表示后面有N组数据，接下来的N行，每行两个整数X和Y$（0<X,Y<1e9)$

**输出**
输出N行，每行输出与输入相应的A和B，使用空格分隔。
### 样例输入 
>2
10 12
8 15

### 样例输出
>4 6
3 5

### 解题思路
比赛的时候我直接进行了暴力枚举,运气好1e9的数据都过了
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b);
    return a;
}

signed main(){
    int n;
    cin >> n;
    while(n--){
        int x,y;
        cin >> x >> y;
        for (int i = 0; i <= x / 2;i++){
            int lcm = i * (x - i) / gcd(i, x - i);
            if(lcm==y){
                cout << i << " " << x - i << endl;
                break;
            }
        }
    }
    return 0;
}
```
### 正解
正解其实是对公式的推导,我们可以得到$A+B=X,A*B=Y*GCD(X,Y)$,所以我们可以得到$A=X/2-\sqrt{X^2-4*Y*GCD(X,Y)}/2,B=X/2+\sqrt{X^2-4*Y*GCD(X,Y)}/2$,代码如下:
```cpp
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int main() {
    int n, x, y;
    cin >> n;
    while (n--) {
        cin >> x >> y;
        int z = gcd(x, y) * y;
        int delta = sqrt(x * x - 4 * z);
        cout << (-x + delta) / -2 << " " << (-x - delta) / -2 << endl;
    }
}
```
## H.指导小组合并
### 题目描述
计软学院有n个蓝桥竞赛指导小组，依次编号为1到n。第i个小组的学生数为ti。 由于这些小组的指导内容完全相同，院长认为应该合并成一个大组，统一培训节省成本。于是，院长和这些小组进行沟通，劝说小组和小组合并。 每次沟通院长需要请吃饭，并且一次只能邀请两个小组参加，花费钱数为两个小组的学生数之和乘以100，沟通的效果是两个小组联合成一个小组（学生数为原来两个小组的学生数之和）

**输入**
输入的第一行包含一个整数N，表示小组的数量。
第二行包含N个正整数，依次表示每个小组的学生数。
其中， $1\leq n \leq 1000,1\leq t_i \leq 10000$。

**输出**
输出一个整数，表示最小花费

### 样例输入 
>4
9 1 3 5

### 样例输出
>3100
### 解题思路 
我的思路是让它不断排序,最小的两个元素相加写到集合里,删除原来的两个元素,然后再排序,直到只剩下一个元素,这个元素就是答案
于是我们就有了它
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n;i++){
        cin >> a[i];
    }
    sort(a.begin(), a.end());
    int xueshengshu;
    int cost = 0;
    while(a.size()!=1){
        xueshengshu = a[0]+a[1];
        cost += xueshengshu * 100;
        a.push_back(xueshengshu);
        a.erase(a.begin(),a.begin()+2);
        sort(a.begin(), a.end());
    }
    cout << cost << endl;
    return 0;
}
```
这样的时间复杂度是$O(n^2)$ ,我想到了这样不断的排序不就是优先队列吗,那么我们可以开一个递增的优先队列来优化,时间复杂度是$O(n\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i = 0; i < n;i++){
        int a;
        cin >> a;
        q.push(a);
    }
    int ans = 0;
    while(q.size()!=1){
        int a = q.top();
        q.pop();
        int b = q.top();
        q.pop();
        ans+=(a+b)*100;
        q.push(a + b);
    }
    cout<<ans<<endl;
    return 0;
}
```
这是我最后的代码,时间复杂度是$O(n\log n)$,空间复杂度是$O(n)$
## I.差的平方和
### 题目描述
有N个整数，请计算它们两两之间差的平方的总和

**输入**
一个正整数N（N小于等于100000），接下来一行有N个绝对值不超过100的整数。
**输出**
这些数两两之间差的平方的总和
### 样例输入
>3
1 2 3
### 样例输出
>6
### 解题思路
100000的数据太大了,我们正常的暴力肯定过不了.我们可以对数学公式进行一些计算化简从而在$O(n)$的时间复杂度内解决这个问题。根据$(a-b)^2=a^2+b^2-2ab$，
$\sum_{n = 1}^{a_n}(a_n - a_{n-1})^2 $= $\sum_{n = 1}^{a_n}a_n^2-2a_na_{n-1}+a_{n-1}^2$=$\sum_{n = 1}^{a_n}a_n^2-2\sum_{n = 1}^{a_n}a_na_{n-1}+\sum_{n = 1}^{a_n}a_{n-1}^2$
然后我们就可以找一些规律了,如图:
[![微信图片_20240701212500.jpg](https://img.picui.cn/free/2024/07/01/6682adec6bdc3.jpg)](https://img.picui.cn/free/2024/07/01/6682adec6bdc3.jpg)
我们就可以找到这样的规律$$\sum_{n = 1}^{n}(n-1)\cdot a_n^2-\sum_{n = 1}^{n}2a_n\cdot\sum_{a_n}^{n}a$$
简而言之,就是把每个数的平方$*(n-1)$倍加起来,然后减去$2*$这个数$*$这个数之后的所有数的和,最后算出来就是答案了
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n;
    cin >> n;
    vector<int> num(n);
    int sum = 0, sum1 = 0;
    for (int i = 0; i < n; i++) {
        cin >> num[i];
        sum1 += num[i];
    }
    for (int i = 0; i < n; i++) {
        sum += (n - 1) * num[i] * num[i];
        sum1 -= num[i];
        sum -= num[i] * sum1 * 2;
    }
    cout << sum;
    return 0;
}
```
我们找出的规律并不是最优的公式,以下是标准的公式推导

原始公式是： $$\sum_{n = 1}^{N}(a_n - a_{n-1})^2$$

展开后得到： $$=\sum_{n = 1}^{N}(a_n^2 - 2a_na_{n-1} + a_{n-1}^2)$$

这可以分解为三个部分： $$=\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1} + \sum_{n = 1}^{N}a_{n-1}^2$$

注意到，$\sum_{n = 1}^{N}a_{n-1}^2$实际上可以转换为$\sum_{n = 0}^{N-1}a_n^2$，因为它只是索引的偏移。因此，如果我们将$a_0$视为$0$（或题目中给定的初始值），这个公式可以简化为： $$=\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1} + \sum_{n = 0}^{N-1}a_n^2$$

由于$\sum_{n = 1}^{N}a_n^2$和$\sum_{n = 0}^{N-1}a_n^2$实际上是相同的（除了在$n=0$时可能的初始值之外），我们可以进一步简化为： $$=2\sum_{n = 1}^{N}a_n^2 - 2\sum_{n = 1}^{N}a_na_{n-1}$$

最终，我们得到简化后的公式： $$=2\left(\sum_{n = 1}^{N}a_n^2 - \sum_{n = 1}^{N}a_na_{n-1}\right)$$
## J.手拉手
### 题目描述
2个人有4只手，随机从4只手中选两只拉起来（注意：有可能自己左手拉右手），拉上以后不分开，再让未拉起来的两只手拉起来，此时，可能形成一个圈，也可能形成两个圈。形成一个圈的概率是2/3，形成两个圈的概率是1/3。
假设两个人为A、B，四只手AL、AR、BL和BR。第一次随机选两只所有的情况为：（AL、AR）、（AL、BL）、（AL、BR）、（AR、BL）、（AR、BR）和（BL、BR）；其中，（AL、AR）和（BL、BR）将形成两个圈，其余4种情况都是形成1个圈。

假设我校有1012名教师，就会有2024只手，现在为了显示大家很团结，随机从这些“手”中找不同的两只拉起来，拉上以后不分开，这样的操作可以进行1012次，问形成几个圈的概率最大？

**输入**
无
**输出**
按要求输出答案
### 解题思路
首先,有一种最简单的不用动脑子的方法就是一眼看过去就会发现概率最大的圈一定不会很大,~~所以我们用`cout<<1,2,3,4...`挨个往过试就好~~
最简单的方法就是此题没有变量,所以，我们可以根据大数极限定律,不断重复模拟这个实验足够多的数
看一下组成几个圈出现的次数最多，就是答案。 
模拟开始时，就是0—2023代表2024只手，随机数x就是选出的第一只手，随机数y(y!=x)
就另一只，x/2==y/2认为x和y来自于同一个人；下一轮模拟时，0---2021代表2022只
手，来自1011个人（上一轮手拉手的两个人，本轮可视为1个人).直至模拟到全部手
都拉上。 
```cpp
int main() 
{ 
    int count[1013]={0}; 
 int i,j; 
 for(i=0;i<10000;++i) 
 { 
  int c=0;//组成的圈数 
  for(j=0;j<1012;++j) 
  { 
   int x=rand()%(2024-j*2);//随机选一只手 
   int y; 
   while(y=rand()%(2024-j*2),x==y);//随机选另一只手 
   if(x/2==y/2)//若x/2等于y/2认为组成圈 
    ++c; 
  } 
  ++count[c]; 
 } 
 for(i=1;i<=1012;++i) 
  cout<<i<<" "<<count[i]<<endl; 
} 
```
运行以上代码，可发现出现4个圈的次数最多，所以答案就是4。
但是运行代码时,我发现每次的结果都是一样的,我感觉十分奇怪,为什么随机出来的结果是一样的,会不会是伪随机,那是不是说明如果是变量的话也是可以这么做的呢?于是我把上面老师的思路改变了一下
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n, m;
    cin>>n;
    m = 2 * n;
    int a[n] = {0};
    for (int j = 0; j < 10000;j++){
        int cnt = 0;
    int x, y;
    for (int i = 0; i < n;i++){
        x = rand() % (m-2*i);
        do{ y = rand() % (m-2*i);
        }while(x==y);
       
        if(x/2==y/2) cnt++;
    }
    a[cnt]++;
    }
    int max=max_element(a,a+n)-a;
    cout << max << endl;
        return 0;
}
```
由于没有判题机,我无法判断这样是不是可以AC
下面是这道题的正解,我们需要用`dp`去实现
[![微信图片_20240701214146.png](https://img.picui.cn/free/2024/07/01/6682b1caeddcd.png)](https://img.picui.cn/free/2024/07/01/6682b1caeddcd.png)
仔细观察上表，会发现$dp[i][j]=dp[i-1][j-1]/(2*i-1)+dp[i-1][j]*(2*i-2)/(2*i-1)$;，以 $dp[5][3]$为
例：$dp[5][3]= dp[4][2]*1/9+ dp[4][3]*8/9$。可解释为： 
5 个人形成3个圈的概率$=$4个人形成2个圈的概率乘以$1/9 + 4$个人形成3个圈的概率乘
以$8/9$。 
试想，5个人10只手，随意拿出一只，再从剩下9只手中，随机选1只，选中同一人的手
的概率$1/9$，不是同一人的手的概率$8/9$；所以，形成3个圈的概率，就是选中同一人的手
概率$1/9$乘以4个人2圈的概率，加上，未选中同一人的手概率$8/9$乘以4个人3圈的概
率。 
有了以上的转移方程，很容易写出以下代码。 
```cpp
double dp[1013][1013]; 
int main() 
{ 
int i,j; 
dp[1][1]=1; 
for(i=2;i<1013;++i) 
for(j=1;j<=i;++j) 
dp[i][j]=dp[i-1][j-1]/(2*i-1)+dp[i-1][j]*(2*i-2)/(2*i-1); 
for(i=0;i<=5;++i) 
cout<<i<<" "<<dp[1012][i]<<endl; 
} 
```
#### 优化
我们可以对这段代码进行状态压缩,从而使得空间复杂度由$O(n^2)$降低到$O(n)$
```cpp
int main() 
{ 
int i,j; 
double dp[1013]={0,1}; 
for(i=2;i<1013;++i) 
for(j=i;j>=1;--j) 
dp[j]=dp[j-1]/(2*i-1)+dp[j]*(2*i-2)/(2*i-1); 
for(i=0;i<=5;++i) 
  cout<<i<<" "<<dp[i]<<endl; 
}
```
## K.学生排队
### 题目描述
有J+R+W名专升本的学生在排队，其中计科专业J名，软工专业R名，网络专业W名。此时，老师发现，从前向后看这一列学生，连续t1个学生同一专业，连续t2个学生同一专业，……，连续tn个学生同一专业。

t1+t2+……+tn等于J+R+W。并且，t1<t2<……<tn。

那么请问在给定J、R、W，并且不区分同一专业学生的情况下，有几种不同的排列方案？

**输入**
输入第一行是案例数N，接下来每一行有3个整数J、R、W
其中， 0≤J、R、W≤50，0≤J+R+W≤90。

**输出**
输出N行，每行一个整数，表示与输入相应的答案。

### 样例输入
>2
3 6 0
1 1 1

### 样例输出
>3
0

**提示**
`3 6 0那组案例的答案是3：jjjrrrrrr,rjjjrrrrr,rrjjjrrrr`
`1 1 1那组案例的答案是0：无法给出单调递增的排列`
### 解题思路
这道题我们可以使用dfs,写递归先找非递归出口,如果所有专业的学生都空了,那么这就是一种可能,在dfs中传入当前的专业和当前的人数,然后遍历每个专业,尝试从当前连续学生数 t 开始，逐个减少该专业的学生数，然后递归调用，之后再将学生数回溯到上一个状态。我们从1个学生,没有专业开始考虑,最后找到可能的方案数ans

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int  a[10], ans;
void dfs(int t, int now) {
    if (!a[1] && !a[2] && !a[3]) {
        ans++;
        return;
    }
    for (int i = 1; i <= 3; i++) {
        if (i == now) continue;
        for (int j = t; j <= a[i]; j++) {
            a[i] -= j;
            dfs(j + 1, i);
            a[i] += j;
        }
    }
    return;
}
int main() {
    int n;
    cin >> n;
    while (n--) {
        ans = 0;
        cin>>a[1]>>a[2]>>a[3];
        dfs(1, 0);
        cout<<ans<<endl;
    }
    return 0;
}
```
以下是老师的做法:
深度优先搜索，就是一堆学生，从前向后排，尝试每一种情况。 
递归函数原型$f(j,r,w,n,z)$;，其中，j、r、w分别表示当前计科、软工、网工所剩学生数（未排列的学生数），n为前面连续同一专业的学生数（保证这轮摆放的学生数不能比前面的少），z为前面学生的专业（保证这轮摆放的学生专业不能与前面相同）。 
```cpp
int cnt;//全局变量保存答案  
void f(int j,int r,int w,int n,int z) 
{ 
 int i; 
 if(!j&&!r&&!w)//全部学生为0，找到1组解，非递归出口 
 { 
    ++cnt; 
    return; 
 } 
 if(z!='J')//前面学生不是计科，尝试放计科学生 
  for(i=n+1;i<=j;++i)//从n+1开始尝试  
   f(j-i,r,w,i,'J');  
 if(z!='R')//前面学生不是软工，尝试放计科软工 
  for(i=n+1;i<=r;++i)//从n+1开始尝试  
   f(j,r-i,w,i,'R');   
 if(z!='W')//前面学生不是网工，尝试放计科网工 
  for(i=n+1;i<=w;++i)//从n+1开始尝试  
   f(j,r,w-i,i,'W');    
}  
int main() 
{ 
    int n,j,r,w; 
    cin>>n;  
 while(n--) 
 { 
  cin>>j>>r>>w; 
  cnt=0;//全局变量回0 
  f(j,r,w,0,'X'); 
  cout<<cnt<<endl;  
 } 
}
```
## 今日总结
 今天将上周比赛的11道题全部写了题解,其中对于dp的状态压缩是我写不出来的,对于倒数第二题的dp的状态转移方程我也找不出来,上周比赛AC了9道题,最后的两道题没有时间看了,不过即使再给我时间我觉得当时我也不一定能做出来就是了,dfs和dp好难 `XD`

# 7月2日
## 答疑
### 题目描述
有𝑛位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。
老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。 一位同学答疑的过程如下：
- 首先进入办公室，编号为 𝑖的同学需要 $𝑠_𝑖$毫秒的时间。
- 然后同学问问题老师解答，编号为 𝑖的同学需要 $𝑎_𝑖$毫秒的时间。
- 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。
- 最后同学收拾东西离开办公室，需要$𝑒_𝑖$毫秒的时间。一般需要 10秒、20秒或 30秒，即 $𝑒_𝑖$,取值为 10000,20000 或 30000。
  

一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。

答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群 里面发消息的时刻之和最小。

**输入描述**
输入第一行包含一个整数 𝑛，表示同学的数量。接下来 𝑛行，描述每位同学的时间。其中第 𝑖行包含三个整数 $𝑠_𝑖, 𝑎_𝑖, 𝑒_𝑖$，意义如上所述。
其中有 $1\leq n \leq 1000,1\leq s_i \leq 60000,1\leq a_i \leq 10^6, e_i \in 10000,20000,30000,$即$e_i$ $10000、20000、30000$之一
**输出描述**
输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。

### 输入输出样例
#### 示例
**输入**
>3
10000 10000 10000
20000 50000 20000
30000 20000 30000

**输出**
>280000

### 解题思路
这道题其实就是一道很简单的结构体排序题,唯一需要注意的就是排序规则的限制,我们需要先排序$s+a+e$的和最小的人,如果总数相等了,再排序$s+a$最小的人,因为当我们计算两个人的时候,假设只有两个数据,我们比较的是 
$$ \left\{ \begin{array}{l} s_1+a_1+e_1+s_2+a_2+s_1+a_1 \\ s_2+a_2+e_2+s_1+a_1+s_2+a_2 \end{array} \right. $$
化简一下易得
$$\left\{ \begin{array}{l} s_1+a_1+e_1 \\ s_2+a_2+e_2 \end{array} \right. $$

所以这就是我们需要比较的东西,同时,当他们三者的和相等时,我们更需要的是s+a更小的人,或者说e更大的人,这样会让等待的时间变得更小
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int summing=0;
struct student{
    long long s, a, e, sum,sum2;
};
bool cmp(student a, student b){
    if(a.sum2==b.sum2) return a.sum < b.sum;
        return a.sum2 < b.sum2;
}

signed main(){
    int n;
    cin >> n;
    vector<student> v(n);
    for (int i = 0;i<n;i++){ 
        cin >> v[i].s >> v[i].a >> v[i].e;
        v[i].sum = v[i].s + v[i].a;
        v[i].sum2 = v[i].s + v[i].a + v[i].e;
    }
   sort(v.begin(), v.end(), cmp);
    vector<int> ans;
    summing += v[0].s + v[0].a;
    int answe=v[0].s + v[0].a;
    for (int i = 1; i < n;i++){
        summing += v[i].s + v[i].a+v[i-1].e;
        answe+=summing;
        }
    cout << answe;
    

        return 0;
}
```
##  等差素数列
### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。
$2,3,5,7,11,13,.... $是素数序列。 类似：$7,37,67,97,127,157$ 这样完全由素数组成的等差数列，叫等差素数数列。
上边的数列公差为 30，长度为 6。
2004 年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。 这是数论领域一项惊人的成果！
有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：
长度为 10 的等差素数列，其公差最小值是多少？

### 解题思路
&emsp;&emsp;这道题我们可以去使用一些容器去实现,首先,我们需要一个map,在map中我们的键设置为所有可能的公差,值设置为多个从x到y的等差数列用结构体实现,我们只需要记录这部分等差数列的起点到终点,然后不断地更新终点,例如,在键为2的值中,我们可以找到 $<3,11>$ ,在我们找到11和13的公差也是2时,而被减数刚好是这个结构体的终点,那么我们就可以改变这个结构体的值,也就是变成 $<3,13>$,如果找不到,那么需要在这个结构体的数组中加入一个新的结构体,把起点定为被减数,终点定为减数,也就是 $<11,13>$ 那么我们的map中的一行就可能可以展示为$2:<3,7>,<11,13>,\dots$这个样子.
&emsp;&emsp;重新梳理一遍,我们需要的最大的容器是一个map,map是一个键为int类型,值为set类型的容器,set是一个我们自定义了结构体的类型的容器,结构体中存放这的是这段子序列的首尾.
| key | value                                                     |
| --- | --------------------------------------------------------- |
| 2   | \<3,7> <11,13> <17,19> <29,31> <41,43> <59,61> <71,73> ···  |
| 4   | \<3,11> <13,17> <19,23> <37,41> <43,47> <67,71> <79,83> ··· |
| 6   | <7,19> <5,29> <31,43> <41,59> <61,79> <83,89> <97,109> ··· |
| ··· | ···                                                       |

那么我们只需要找到长度为10的等差素数列,他的key就是我们要的答案,比如说,如果$end-begin=key*(n-1),key$就是我们要的答案
### 代码实现
```cpp
// 答案是210,直接输出即可
#include <iostream>
using namespace std;
int main() {
    // 请在此输入您的代码
    printf("210");
    return 0;
}
// 下面是算出210的C++代码
#include <cmath>
#include <deque>
#include <iostream>
#include <map>
#include <set>
using namespace std;
struct T {
    int from, to;
    T(int f, int t) : from(f), to(t) {}
    bool operator<(const T &right) const { return to < right.to; }
};
int main() {
    deque<int> d;
    map<int, set<T>> m;
    d.push_back(3);
    int i, j, from, to;
    for (i = 5;; i += 2) {
        int sqrti = (int)sqrt(i);
        for (j = 0; d[j] <= sqrti; j++)
            if (i % d[j] == 0)
                break;
        if (d[j] > sqrti) {
            to = i;
            for (j = 0; j < d.size(); ++j) {
                from = d[j];
                set<T> &set_t = m[to - from];
                set<T>::iterator re = set_t.find(T(0, from));
                if (re != set_t.end()) {
                    T temp = *re;
                    set_t.erase(re);
                    set_t.insert(T(temp.from, to));
                    if ((to - temp.from) / (to - from) == 9) {
                        cout << (to - from) << endl;
                        goto L;
                    }

                } else {
                    set_t.insert(T(from, to));
                }
            }
            d.push_back(i);
        }
    }
L:;
    // map<int,set<T> >::iterator re;
    // for(re=m.begin(),i=0;re!=m.end()&&i<3;re++,i++)
    // {
    //         cout<<re->first<<":";
    // for(set<T>::iterator rere=
    // re->second.begin();rere!=re->second.end();rere++)
    //    cout<<"("<<rere->from<<","<<rere->to<<") ";
    //        cout<<endl;
    // }
}
```
注释中的代码是查看表的结果.
### 优化
这道题我们可以用$O(1)$实现,我们用脑子随便一想就可以知道,我们要求长度为$n$的等差数列子序列,他的公差一定等于一到n的所有质数相乘,也就是说,长度为10的等差数列子序列的公差一定是$2*3*5*7=210$,非常的邪门.
```python
print(2*3*5*7)
```

## 测试次数
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**
X 星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。
X 星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的 2  楼。
如果手机从第 7 层扔下去没摔坏，但第 8 层摔坏了，则手机耐摔指 =7 。 特别地，如果手机从第 1 层扔下去就坏了，则耐摔指数 =0 。 如果到了塔的最高层第 n 层扔没摔坏，则耐摔指数 =n 。
为了减少测试次数，从每个厂家抽样 3 部手机参加测试。
某次测试的塔高为 1000 层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？

**请填写这个最多测试次数。**

运行限制
`最大运行时间：1s`
`最大运行内存: 128M`

### 解题思路
&emsp;&emsp;我们可以不顺着题目的思路想,我们去找出3个手机在砸多少次的时候能够得到1000层,那么这道题就很好写了,在只有一个手机的时候,我们只能砸i次得到i层的结果,因为一个手机只能一层一层去砸着看,两个手机的时候,当我们随便砸一个,如果手机被砸坏了,那么我们还剩下的手机数就是上一层的少一次砸的机会的结果,如果手机没有砸,那它的结果就是这一层可以砸的数减1,两种情况相加加上你砸的这一次就是这道题的状态转移方程了
|     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---- |
|  0   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11   |
|  1  | 0   | 1   | 3   | 6   | 10  | 15  | 21  | 28  | 36  | 45  | 55  | 66   |
| 2   | 0   | 1   | 3   | 7   | 14  | 25  | 41  | 63  | 92  | 129 | 175 | 231  |
| 3   | 0   | 1   | 3   | 7   | 15  | 30  | 56  | 98  | 162 | 255 | 385 | 561  |
| 4  | 0   | 1   | 3   | 7   | 15  | 31  | 62  | 119 | 218 | 381 | 637 | 1023 |
| 4   | 0   | 1   | 3   | 7   | 15  | 31  | 63  | 126 | 246 | 465 | 847 | 1485 |

状态转移方程为: $dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+1$
然后我们只需要找到当$i==3$时,$j==?$的时候,$dp[i][j]>=1000$即可
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int a[100][100]={0};
    for(int i=0;i<100;i++){
        a[0][i]=i;
        a[i][0]=0;
    }
    for(int i=1;i<100;i++){
        for(int j=1;j<100;j++){
            a[i][j]=a[i-1][j-1]+a[i][j-1]+1;
        }
    }
    for (int i = 0; i < 100;i++){
        if(a[2][i]>1000){
            cout << i;
            break;
        }
    }

        return 0;
}
```
## K倍区间
### 题目描述
给定一个长度为 N 的数列， $A_1​,A_2​,⋯A_N$ ​，如果其中一段连续的子序列  $A_i​,A_{i​+1},⋯A_j$​ <small>$( i \leq j )$</small> 之和是 K 的倍数，我们就称这个区间  $[ i , j]$ 是 $K$ 倍区间。
你能求出数列中总共有多少个 $K$ 倍区间吗？

**输入描述**
第一行包含两个整数 N  和 K$( 1\leq N,K\leq 105 )$。
以下 N 行每行包含一个整数 $A_i​ (1\leq A_i​ \leq 105)$

**输出描述**
输出一个整数，代表 K 倍区间的数目。

### 输入
>5 2
1
2
3
4
5

### 输出
>6

`运行限制`
 `最大运行时间：2s`
`最大运行内存: 256M`

### 解题思路
&emsp;&emsp;这道题我们如果暴力的使用前缀和的话去遍历的话,时间复杂度是$O(n^2)$,这样的时间复杂度是不可接受的,会导致TLE
&emsp;&emsp;我们可以通过同余原理,假设有数的串为xxxxxxyyyyyyy，一堆x加起来%k得n，一堆x和y加起来%k也得n，那么这一堆y的和就是n的倍数。
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    ll n, k;
    cin >> n >> k;
    vector<ll> a(k,0);
    ll x, y=0;
    for(ll i = 0;i<n;i++){
        cin >> x;
        y=(y+x)%k;
        a[y]++;
    }
    ll sum = 0;
    for(ll i = 0;i<k;i++){
        sum += a[i]*(a[i]-1)/2;
    }
    sum += a[0];
    cout << sum;
    return 0;
}
```

# 7月3日
## 老周的运动
### 题目描述
老周最近几年日渐发福，因此决定运动起来。因为老周是程序员，喜欢有规律的运动。老周在三期操场上画出了坐标系，初始位置是$(x,y)=(0,0)$点 老周按照一定的规则进行跑步，面对坐标系上北下南左西右东。 起始时老周面朝东方，第i个阶段会向前走i米，并向左转。请计算老周经过n个阶段后的坐标。

**输入**
一行一个整数 n，代表老周跑的阶段数。$1\leqslant n \leqslant 2 \cdot 10^9$

**输出**
一行两个整数，表示老周n阶段后位置 x 和 y坐标，中间一个空格分隔。

**样例输入**
>5

**样例输出**
>3 -2
### 解题思路
![1721285754764.png](https://img.picui.cn/free/2024/07/18/6698bbd98ff09.png)
我们先按照题目要求把他模拟出来,找一找其中的规律,我们可以发现,坐标的集合为$(1,0),(1,2),(-2,2),(-2,-2),(3,-2),(3,4),(-4,4)\cdots \  \cdots $
| **row** | **col** |
| ------- | ------- |
| 1       | 0       |
| 1       | 2       |
| -2      | 2       |
| -2      | -2      |
| 3       | -2      |
| 3       | 4       |
| -4      | 4       |
| -4      | -4      |
| 5       | -4      |
| 5       | 8       |
| -6      | 8       |
| -6      | -8      |
| 7       | -8      |
| 7       | 16      |
| -8      | 16      |
| -8      | -16     |

到这里其实规律就已经找出来了,我们可以发现,x轴每两个为一组,x的值为偶数时,他是负数,奇数时是正数,y的值四个为一组,第一个是0当作特判,每组的前两个为正数,后两个为负数
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int x=0,y=0;
    int n;
    cin>>n;
    if(n%2==0) x=n/2;
    else x=(n+1)/2;
    if(x%2==0) cout<<'-';
    cout<<x<<" ";
    if(n==1) y=0;
    else{
        if((n-1)%4==0) y=((n-1)/4)*2;
        else y=((((n-1)/4)+1))*2;
    }
    if(((n-1)%4==0)||n%4==0)cout<<'-';
    cout<<y<<endl;
}
```
### 优化
我们更改一下逻辑就可以找到两个公式几行代码搞定
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    int x, y;
    x = (n + 1) / 2;
    if(x%2==0) x = -x;
    y = (n + 2) / 4 * 2;
    if((n+2)%4>=2) y = -y;
    cout<<x<<" "<<y<<endl;
    return 0;
}
```
## 称硬币
在研究最少砝码的问题之前,先引入一道经典的智力问题--称硬币
在研究称硬币问题之前,先解一道简单的硬币问题:
**在27个硬币中有一个硬币比其他的硬币轻,如何用天平称3次称出来**
- 我们可以先拿九个和另外九个比较,我们很明显的就能知道是3堆9个硬币中哪一堆轻了,小于就是左边轻,大于就是右边轻,等于就是剩下的那堆轻
- 再拿轻了的堆中的三个和三个比较,我们很明显就能知道是哪三个轻了
- 再拿一个和一个比较,我们就能知道哪一个轻了
  

***回到称硬币问题***
  ### 题目描述
  有13枚硬币。其中有12枚真币和一枚假币。假币和真币重量不同，但不知道假币比真币轻还是重。现在，用一架天平称了这些币三次，告诉你称的结果，请你找出假币并且确定假币是轻是重。
  ### 解题思路
  通过上面内个简单的问题,我们其实就可以知道天平可以一次称三堆硬币了,但是与上面的小问题不同的是,我们现在不知道了假币是轻了还是重了,所以我们就无法知道在称重的时候,哪一堆硬币是标准的,但是硬币无非就是两种情况,要么轻要么重,所以本来我们称三次可以称$3^3=9$,称n次就可以找出$3^n$个硬币是否有一个轻了,那么现在如果不知道硬币的轻重,我们知道的就是$3^n/2$个硬币,那么我们就可以通过这个方法找出假币了
  - 我们先将12个硬币分成3组,每组4个,我们可以把它们命名成$A_1,A_2,A_3$我们任选其中的两组进行称重,假如我们选的是$A_1$和$A_2$,那么我们无非得到的是三种情况,$A_1$轻,$A_1$重,$A_1$和$A_2$一样重我们一步一步来分析
  - 假设一样重的话,那么$A_3$里就有一个是假的,同时$A_1$和$A_2$一定都是真的,那么我们就可以把$A_3$分成两组,一组两个,一组三个,我们可以把它们命名成$B_1,B_2$,在真的两堆中随便取出三个,命名成$B_3$,拿$B_1$和$B_2$比较,如果一样重,那么$B_3$中有一个是假的,我们就可以找出假币了,如果不一样重,那么我们就可以知道假币是轻了还是重了,既然已经知道轻重了,那么问题就和上面的小问题一样了,$3^n=3$那么n就是1,也就是需要称一次,我们成功在三次拿下这道问题
  - 假设$A_1$重,我们把$A_1$中拿出三个,把$A_2$中拿出三个补给$A_1$,把$A_3$中拿出三个补给$A_2$
  - - 此时如果天平平衡了,那么就说明假币在$A_1$拿掉的三个中,而且假币轻了,此时再称一次就可以得到答案
  - - 如果天平反过来了,也就是$A_2$这一堆重,就说明$A_2$传给$A_1$的三个中有一个是假的,而且假币轻了,此时再称一次就可以得到答案
  - - 如果天平还是$A_1$重,那么就说明$A_1$没动的一个和$A_2$没动的一个中有一个是假的,我们拿一枚真币去跟它们比较一下就知道了
  - 假设$A_1$轻的方法和上面同理

  ### 编码分析
  我们现在需要做一个通用的递归程序做到在n个硬币时最少多少次能够找到坏的硬币
  ### 需求分析
  N个硬币,随机选一个为坏的,找到函数寻找坏了的硬币
  ### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int f(int n) {
    if (n <= 3) return 1 ;
    int heap = n / 3;
    int worst = 0x3f3f3f3f;
    for (int i = heap; i < heap + 2; ++i) {
        int peiping = n - 2 * i;
        worst = min(worst, 1 + max(f(i), f(peiping)));
    }

    return worst;
}

int main() {
    int n;
    cin>>n;
    cout<<f(n)<<endl;

    return 0;
}
```



## 最少砝码
### 题目描述
你有一架天平。现在你要设计一套砝码，使得利用这些砝码可以称出任意 小于等于 N 的正整数重量。
那么这套砝码最少需要包含多少个砝码？
注意砝码可以放在天平两边。
输入格式
输入包含一个正整数 N。
输出格式
输出一个整数代表答案。

**样例输入**
>7

**样例输出**
>3

样例说明
3 个砝码重量是 1、4、6 可以称出 1  至 7 的所有重量。
$1 = 1$； 
$2 = 6 – 4$ 
$3 = 4 − 1$； 
$4 = 4$； 
$5 = 6 − 1$； 
$6 = 6$； 
$7 = 1 + 6$； 
少于 3  个砝码不可能称出 1 至 7   的所有重量。
评测用例规模与约定
对于所有评测用例，$1 \leqslant N \leqslant 1000000000 $
`运行限制`
` 最大运行时间：1s`
 `最大运行内存: 512M`

### 解题思路
我们可以通过硬币问题看出,对于天平来说,3很特殊,那么样例给出的说明其实不是最优解,最优解是1.3.9,这三个天秤能够表达的n为13,四个天秤就是1,3,9,27了,它能够表达的n为40,那么我们可以画一张表格,找出规律
| **砝码数** | **N** |
| -----| --------   |
| 1     | 1         |
| 2     | 4         |
| 3     | 13        |
| 4     | 40        |
| 5     | 121       |

规律已经很明显了,我们的$N_n=3 \cdot N_{n-1}+1$,那么我们输入的$N_n \leqslant N<N_{n+1}  $时, n就是我们要找的砝码数
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
//1,3,9,27一定是最优砝码
signed main(){
    int n;
    cin >> n;
    if(n == 1){
        cout << 1 << endl;
        return 0;
    }
    vector<int> a;
    a.push_back(1);
    for (int i = 1;;i++){
         a.push_back(a.back() * 3+1);
         if(a.back() >= n){
             cout << i+1 << endl;
             return 0;
         }
    }
        return 0;
}
```
## 后缀表达式
### 题目描述
给定 $N$ 个加号、$M$ 个减号以及 $N + M + 1$个整数 $A_1,A_2,⋅⋅⋅,A_{N+M+1}$​，小明想知道在所有由这 $N$ 个加号、$M$  个减号以及 $N + M +1$ 个整数凑出的合法的 后缀表达式中，结果最大的是哪一个？
请你输出这个最大的结果。
例如使用 `1 2 3 + -`，则 `"2 3 + 1 -"` 这个后缀表达式结果是 4，是最大的。
**输入描述**
第一行包含两个整数 $N$ , $M$ 
第二行包含 $N + M + 1$  个整数  $A_1,A_2,⋅⋅⋅,A_{N+M+1}$
其中， $0 \leqslant N,M \leqslant 10^5$，$-10^9 \leqslant A_i \leqslant 10^9$
**输出描述**
输出一个整数，代表答案。
输入输出样例

### 输入
>1 1
1 2 3

### 输出
>4

### 题目分析
这道题其实跟后缀表达式关系不大,我们只需要知道,如果只有加法的话,给全部的数求和就行,而如果有减法的话,无论它有多个减法,我们都可以通过括号化成只有一个减法,所以我们只需要减去排序后数组中的第一个元素也就是最小的内个元素就可以了.如果有负数但它不全是负数的话,我们一定可以把它化成正数,所以求和变成了求绝对值的和。如果全是负的话,有1个负数无论如何要做加法或减法的左操作数，那样只有这个数是负数，其他的都是正的。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int N, M;
    cin >> N >> M;
    vector<int> a(N + M + 1);
    int x, i;
    int sum = 0;
    for (i = 0; i < N + M + 1; i++)
        cin >> a[i];
    sort(a.begin(), a.end());

    if (!M) {
        for (i = 0; i < N + M + 1; i++)
            sum += a[i];
    } else if (a[0] >= 0) {
        sum -= a[0];
        for (i = 1; i < N + M + 1; i++)
            sum += a[i];
    } else {
        for (i = 0; i < N + M + 1; i++)
            sum += abs(a[i]);
        if (a[N + M] < 0)
            sum += 2 * a[N + M];
    }
    cout << sum << endl;

    return 0;
}
```
____

## 关于表达式
表达式的三要素是操作数个数、优先级和结合性
#### 操作数个数

  大多数基本算术运算符（如`+`, `-`, `*`, `/`）都是二元运算符，意味着它们需要两个操作数,而单目运算符（如`-`, `!`）只需要一个操作数。

#### 优先级

  优先级决定了运算符的执行顺序。例如，在表达式 `(1+2)*3/4-(5+6)` 中，乘法和除法的优先级高于加法和减法。左括号的优先级最低，仅用于改变运算的顺序。

#### 结合性

  结合性决定了同优先级运算符的计算顺序。大多数算术和逻辑运算符是左结合的，意味着从左到右计算。但赋值运算符（如`=`和`+=`）以及某些单目运算符（如`-`, `!`, `&`, `*`）是从右向左结合的。`a+=b; a=b=1; -a; !a; &a; *a;` ,这些符号都是从右向左结合的

#### 使用栈进行中缀转后缀

为了将中缀表达式转换为后缀表达式，我们可以使用一个栈。
先初始化一个空的运算符栈和一个后缀表达式列表。然后直接在空栈中压入一个左括号,这么做的目的是让栈一直不为空,从而方便的判断是否结束运算,然后从左至右扫描中缀表达式中的每个字符。如果是操作数，直接添加到后缀表达式列表。如果是左括号`(`，压入栈。如果是运算符，与栈顶运算符比较优先级：如果栈为空或栈顶运算符优先级更低，压入栈。如果栈顶运算符优先级更高或相等，则将栈顶运算符弹出并加入后缀表达式列表，重复此步骤直到当前运算符可以压入栈。如果是右括号`)`，则连续弹出栈顶运算符并加入后缀表达式列表，直到遇到左括号并将其丢弃。表达式扫描完成后，将栈中剩余的运算符依次弹出并加入后缀表达式列表。

#### 计算后缀表达式的值
使用一个栈存储操作数。遇到数字，压入栈。遇到运算符，从栈中弹出两个操作数，进行计算，将结果压回栈.当所有元素处理完毕，栈顶元素即为表达式的值。

# 7月4日
## 最短路
### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。

如下图所示，G 是一个无向图，其中蓝色边的长度是 1、橘色边的长度是 2、绿色边的长度是 3。
![图片描述](https://doc.shiyanlou.com/courses/uid1580206-20210312-1615537376560)

则从 A 到 S 的最短距离是多少？
### 解题思路
这道题其实用floyd算法更好写,因为就19个点,但我就想用dijsktra
我们把所有点的权值都录入到邻接矩阵中，然后从A点开始，用dijstra算法求出A到所有点的最短距离，然后输出S点的最短距离即可。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200, n = 19;
int dist[N];
int s[1001];
int g[N][N];
void add(char x, char y, int c) {
    int a = x - 'A' + 1;
    int b = y - 'A' + 1;
    g[a][b] = g[b][a] = c;
}
int dij(int v) {
    int i, j, mindis, u;
    for (i = 1; i <= n; i++) {
        dist[i] = g[v][i];
        s[i] = 0;
    }
    s[v] = 1;
    for (i = 1; i <= n; i++) {
        mindis = 0x3f3f3f3f;
        for (j = 1; j <= n; j++) {
            if (s[j] == 0 && dist[j] < mindis) {
                mindis = dist[j];
                u = j;
            }
        }
        s[u] = 1;
        for (j = 1; j <= n; j++) {
            if (s[j] == 0) {
                if (g[u][j] < 0x3f3f3f3f && dist[u] + g[u][j] < dist[j]) {
                    dist[j] = dist[u] + g[u][j];
                }
            }
        }
    }
    return 0;
}
int main(){
    for (int i = 1; i <= 20; i++) {
        for (int j = 1; j <= 20; j++) {
            g[i][j] = 0x3f3f3f3f;
        }
        g[i][i] = 0;
    }
    add('A', 'B', 2);
    add('A', 'C', 1);
    add('A', 'D', 1);
    add('A', 'D', 1);
    add('B', 'J', 2);
    add('B', 'G', 1);
    add('C', 'D', 3);
    add('C', 'F', 3);
    add('C', 'G', 3);
    add('D', 'E', 1);
    add('D', 'G', 2);
    add('D', 'H', 1);
    add('D', 'I', 2);
    add('E', 'H', 1);
    add('E', 'I', 3);
    add('F', 'G', 1);
    add('F', 'J', 1);
    add('G', 'F', 1);
    add('G', 'I', 3);
    add('G', 'K', 2);
    add('H', 'I', 1);
    add('H', 'L', 2);
    add('I', 'M', 3);
    add('J', 'S', 2);
    add('K', 'N', 1);
    add('K', 'L', 3);
    add('K', 'P', 2);
    add('L', 'M', 1);
    add('L', 'R', 1);
    add('M', 'N', 2);
    add('M', 'Q', 1);
    add('M', 'S', 1);
    add('N', 'P', 1);
    add('O', 'P', 1);
    add('O', 'Q', 1);
    add('O', 'R', 3);
    add('R', 'S', 1);
    dij(1);
    cout<<dist[19]<<endl;
    return 0;
}
```
## 递增序列
### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。

对于一个字母矩阵，我们称矩阵中的一个递增序列是指在矩阵中找到两个字母，它们在同一行，同一列，或者在同一 45 度的斜线上，这两个字母从左向右看、或者从上向下看是递增的。

例如，如下矩阵中

>LANN
QIAO

有$LN、LN、AN、AN、IO、AO、LQ、AI、NO、NO、AQ、IN、AN $等 13 个 递增序列。注意当两个字母是从左下到右上排列时，从左向右看和从上向下看 是不同的顺序。

对于下面的 
30 行 50 列的矩阵，请问总共有多少个递增序列？

>VLPWJVVNNZSWFGHSFRBCOIJTPYNEURPIGKQGPSXUGNELGRVZAG
SDLLOVGRTWEYZKKXNKIRWGZWXWRHKXFASATDWZAPZRNHTNNGQF
ZGUGXVQDQAEAHOQEADMWWXFBXECKAVIGPTKTTQFWSWPKRPSMGA
BDGMGYHAOPPRRHKYZCMFZEDELCALTBSWNTAODXYVHQNDASUFRL
YVYWQZUTEPFSFXLTZBMBQETXGXFUEBHGMJKBPNIHMYOELYZIKH
ZYZHSLTCGNANNXTUJGBYKUOJMGOGRDPKEUGVHNZJZHDUNRERBU
XFPTZKTPVQPJEMBHNTUBSMIYEGXNWQSBZMHMDRZZMJPZQTCWLR
ZNXOKBITTPSHEXWHZXFLWEMPZTBVNKNYSHCIQRIKQHFRAYWOPG
MHJKFYYBQSDPOVJICWWGGCOZSBGLSOXOFDAADZYEOBKDDTMQPA
VIDPIGELBYMEVQLASLQRUKMXSEWGHRSFVXOMHSJWWXHIBCGVIF
GWRFRFLHAMYWYZOIQODBIHHRIIMWJWJGYPFAHZZWJKRGOISUJC
EKQKKPNEYCBWOQHTYFHHQZRLFNDOVXTWASSQWXKBIVTKTUIASK
PEKNJFIVBKOZUEPPHIWLUBFUDWPIDRJKAZVJKPBRHCRMGNMFWW
CGZAXHXPDELTACGUWBXWNNZNDQYYCIQRJCULIEBQBLLMJEUSZP
RWHHQMBIJWTQPUFNAESPZHAQARNIDUCRYQAZMNVRVZUJOZUDGS
PFGAYBDEECHUXFUZIKAXYDFWJNSAOPJYWUIEJSCORRBVQHCHMR
JNVIPVEMQSHCCAXMWEFSYIGFPIXNIDXOTXTNBCHSHUZGKXFECL
YZBAIIOTWLREPZISBGJLQDALKZUKEQMKLDIPXJEPENEIPWFDLP
HBQKWJFLSEXVILKYPNSWUZLDCRTAYUUPEITQJEITZRQMMAQNLN
DQDJGOWMBFKAIGWEAJOISPFPLULIWVVALLIIHBGEZLGRHRCKGF
LXYPCVPNUKSWCCGXEYTEBAWRLWDWNHHNNNWQNIIBUCGUJYMRYW
CZDKISKUSBPFHVGSAVJBDMNPSDKFRXVVPLVAQUGVUJEXSZFGFQ
IYIJGISUANRAXTGQLAVFMQTICKQAHLEBGHAVOVVPEXIMLFWIYI
ZIIFSOPCMAWCBPKWZBUQPQLGSNIBFADUUJJHPAIUVVNWNWKDZB
HGTEEIISFGIUEUOWXVTPJDVACYQYFQUCXOXOSSMXLZDQESHXKP
FEBZHJAGIFGXSMRDKGONGELOALLSYDVILRWAPXXBPOOSWZNEAS
VJGMAOFLGYIFLJTEKDNIWHJAABCASFMAKIENSYIZZSLRSUIPCJ
BMQGMPDRCPGWKTPLOTAINXZAAJWCPUJHPOUYWNWHZAKCDMZDSR
RRARTVHZYYCEDXJQNQAINQVDJCZCZLCQWQQIKUYMYMOVMNCBVY
ABTCRRUXVGYLZILFLOFYVWFFBZNFWDZOADRDCLIRFKBFBHMAXX

`运行限制`
`最大运行时间：1s`
`最大运行内存: 128M`
### 解题思路
这道题其实就是一个暴力枚举的题目，我们可以枚举每一个点，五个方向都找一遍就好

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
       vector<vector<char>> a(31, vector<char>(51));
       for(int i = 1; i <= 30; i++){
           for(int j = 1; j <= 50; j++){
               cin>>a[i][j];
           }
       }
       int ans = 0;
       for(int i = 1; i <= 30; i++){
           for(int j = 1; j <= 50; j++){
               for (int k = j + 1; k <= 50; k++){
                   if(a[i][j] < a[i][k]){
                       ans++;
                   }
               }
               for(int k = i + 1; k <= 30; k++){
                   if(a[i][j] < a[k][j]){
                       ans++;
                   }
               }
               for(int k =1; k <= 30; k++){
                   for(int l = 1; l <= 50; l++){
                        if(abs(k-i)==abs(l-j)&&a[i][j]<a[k][l]&&!(i>=k&&j>=l)){
                             ans++;
                        }
                   }
               }
           }
       }
       cout << ans;
    cout << 6;
    return 0;
}
```

## 分巧克力
### 题目描述
儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有 N 块巧克力，其中第 I 块是  $H_i ​\times W_i $的方格组成的长方形。为了公平起见，
小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：

- 形状是正方形，边长是整数;
- 大小相同;
  

例如一块 $6 \times 5$ 的巧克力可以切出 $6$ 块 $2 \times 2$ 的巧克力或者 $2$ 块 $3 \times 3 $的巧克力。
当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

### 输入描述
第一行包含两个整数 $N,K(1 \leq N,K \leq 10^5)$。
以下 N 行每行包含两个整数 $H_i​,W_i​(1≤H_i​,W_i​≤10^5)$。
输入保证每位小朋友至少能获得一块 $1 \times 1$ 的巧克力。

### 输出描述
输出切出的正方形巧克力最大可能的边长。

>输入
2 10
6 5
5 6

>输出
2

`运行限制`
`最大运行时间：2s`
`最大运行内存: 256M`
### 解题思路
这是一道很二分答案题目,二分答案要求我们找到最大值或者最小值,这道题我们要找到最大值,一个很经典的板子是
```cpp
int find(int l, int r) {
    int ans = 0;
    while (l <= r) {
        int mid = l + r >> 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return ans;
}
```
然后在主函数中`int`一个l=0,r=1e9,然后输出`find(l,r)`即可

____

这里面至少在我写的二分答案中一直都是不变的,而二分答案的难点就是在正确的写出`check`函数,针对这道题而言,就是要求我们找出在用mid作边长切出的巧克力中满足这个数大不大于K,我们需要找到的就是最大的最小值
```cpp
bool check(int x) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        cnt += (a[i].first / x) * (a[i].second / x);
    }
    return cnt >= k;
}
```
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, k;
vector<pair<int, int>> a;
bool check(int x) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        cnt += (a[i].first / x) * (a[i].second / x);
    }
    return cnt >= k;
}
int find(int l, int r) {
    int ans = 0;
    while (l <= r) {
        int mid = l + r >> 1;
        if (check(mid)) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return ans;
}
signed main() {

    cin >> n >> k;
    a.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i].first >> a[i].second;
    }
    int l = 0, r = 1e9;
    cout << find(l, r) << endl;

    return 0;
}
```
## 迷宫
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。

>010000
000100
001001
110000

迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。

对于上面的迷宫，从入口开始，可以按 `DRRURRDDDR` 的顺序通过迷宫， 一共 10 步。其中 𝐷、𝑈、𝐿、𝑅 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫（ 30 行, 50 列），请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。

请注意在字典序中 $𝐷 \lt 𝐿 \lt 𝑅 \lt 𝑈$

>01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000

`运行限制`
`最大运行时间：1s`
`最大运行内存: 256M`

### 解题思路
这道题最开始我使用了$DFS$,但是这个迷宫实在是太大了,如果用$DFS$搜索它的话根本搜索不出来,所以我们只能选择用$BFS$,但是它跟传统的$BFS$不太一样,我们需要找到的是它具体是怎么走的,所以我们还需要一个`string`来记录它的路径

对于BFS的做法,我一般是这么做的,绝大部分的简单BFS都可以套用这种方式

```cpp
Q.push(初始状态); // 将初始状态入队

while (!Q.empty()) { // 取出队首
    State u = Q.front(); 
    Q.pop(); // 出队
    for (枚举所有可扩展状态) // 找到u的所有可达状态v
        if (是合法的) // v需要满足某些条件，如未访问过、未在队内等
            Q.push(v); // 入队（同时可能需要维护某些必要信息）
}
 
```

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int x, y, step;
    string path;
};

char mp[30][50];
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};
int n = 30, m = 50;
string res = "";

void bfs() {
    queue<Node> q;
    q.push(Node(0, 0, 0, ""));
    mp[0][0] = '1';
    char directions[] = {'R', 'D', 'L', 'U'};
    while (!q.empty()) {
        Node node = q.front();
        q.pop();
        if (node.x == n - 1 && node.y == m - 1) {
            res = node.path;
            // cout << node.step << endl;
            cout << res << endl;
            return;
        }
        for (int i = 0; i < 4; i++) {
            int nx = node.x + dx[i];
            int ny = node.y + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && mp[nx][ny] == '0') {
                mp[nx][ny] = '1';
                q.push(Node(nx, ny, node.step + 1, node.path + directions[i]));
            }
        }
    }
}

int main() {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> mp[i][j];
        }
    }
    bfs();
    return 0;
}
```

# 7月5日

**昨天晚上进行了校赛的热身赛,今天讲了其中的一些题目**
## 这是一道莫比乌斯反演问题
### 题目描述
有这样一个函数 $f(x, y)$,$x$ 和 $y$ 为正整数,定义 $f(x, y)$ 为$（x + y）$除以 $1e8$ 的 余数

给你一个长度为 n 的正整数序列 a，让你求出下面表达式的值：

$$ \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} f(a_i, a_j) $$

**（注意：并没有让你计算总和除以 1e8 的余数）**

### 输入
第一行，包含一个正整数 n（2≤n≤3×1e5）代表序列的长度

第二行，包含 n 个正整数的集合 a（1≤ai<1e8）

### 输出
输入一个数，表示表达式的结果

> 输入
3
3 50000001 50000002

>输出
100000012

**提示**
$f(a1 , a2) = 50000004$
$f(a1 , a3) = 50000005$
$f(a2, a3) = 3$

因此，答案为 $f(a1 , a2) + f(a1 , a3) + f(a2, a3) = 100000012$

思路
首先，我们对每个数进行预处理，将其乘以(n-1)，接着，对整个数列进行排序，这一步是为了便于我们之后的查找操作，确保我们能够有效地识别出哪些数对的和超过了1e9。
随后，我们遍历排序后的数列，对于每一个数，我们执行一次二分查找，目的是寻找与之配对的第一个数，使得这对组合的和首次达到或超过1e8。具体来说，我们从当前数的下一个位置开始，直到数列的末尾进行搜索。如果中间位置的数与当前数的和已经达到或超过了1e9，那么我们缩小搜索范围至中间位置的左边，否则我们扩大搜索范围至中间位置的右边。这样，我们能够确定一个分割点，在该点右侧的所有数与当前数配对时都能满足条件。每找到一个这样的分割点，我们就知道从该点到数列末尾的所有数都能与当前数形成有效的数对，因此我们需要从答案中减去这些数对的累积值，即(n - 分割点位置 + 1) * 1e8。这个算法的时间复杂度是\(O(n \log n)\)

```cpp
#include <bits/stdc++.h>
#define int long long
signed main() {
    int n;
    const int MOD = 1e8;
    vector<int> a(n + 1);
    int res = 0;

    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        res += a[i] * (n - 1);
    }
    sort(a.begin() + 1, a.begin() + n + 1);
    for (int i = 1; i <= n; i++) {
        int l = i + 1, r = n + 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (a[i] + a[mid] >= MOD) r = mid;
            else l = mid + 1;
        }
        res -= (n - l + 1) * MOD;
    }
    cout << res << endl;
    return 0;
}
```
## 三角形里的正方形
![](https://cdn.luogu.com.cn/upload/image_hosting/3fnqi74y.png)
### 题目描述
在一个二维平面上有三个点$A(a, 0), B(0, b), C(0, 0), $求$ACB$三点构成的三角形内含有多少个面积为1的正方形，不足一整个正方形的，超过该正方形一半面积就算1个正方形。例如当 $a=8,b=6$时有$24$个正方形
**输入**
两个非负整数$a$, $b$ $(1 \leqslant a \leqslant 10^6)$, $(1 \leqslant b \leqslant 10^6)$
**输出**
正方形个数
>样例输入
6 8

>样例输出
24

### 思路
我的思路是找到每个正方形左上角的点,如果这个点大于等于相同X下斜边的Y轴,那么这就是一个合法的三角形

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin >> n;
    vector<string> mp(n);
    int len = 0;
    for (int i = 0; i < n;i++){
        string  _;
        cin >> _;
        mp[i] = _;
        int tmp = mp[i].size();
        len = max(len, tmp);
    }
    map<string, int> mpp;
    map<string, int>  bb;
    for (int i = 0; i < n;i++){
        int j = 0;
        while(mp[i].size()<len){
            mp[i] = '0' + mp[i];
            j++;
        }
        // cout << j << endl;
        // cout << mp[i]<<endl;
        mpp[mp[i]] = j;
        // cout<<mpp[mp[i]]<<endl;
    }
    sort(mp.begin(), mp.end());

    string ans = "";
    for (int i = 0; i < n;i++){
        string s = mp[i];
        mp[i] = mp[i].substr(mpp[mp[i]], mp[i].size() - mpp[mp[i]]);
        ans += mp[i];
    }
    cout<<ans;
        return 0;
```

  ## 数组切割
  ### 题目描述
你有一个包含 n 个整数 $a_1，a_2，a_3，……$的数组，保证 $n$ 是偶数。 

现在请你将这个数组分成 $\frac{n}{2}$ 段，定义第 $i$ 段的值 $f(i)$ 为 $i * (a_l + a_(l+1) + … + a_(r - 1) + a_r)$，$l$ 为第 $i$ 段左端点，$r$为第 $i$ 段右端点。

换句话说，第 i 段的值 f(i) 为 (该段的元素和 * i)。 现在求 $f(1) + f(2) + … + f(n/2)$ 的最大值是多少

输入
第一行包含一个整数 $n (1 <= n <= 1e5)$ —— 数组的大小

第二行包含 n 个整数 $ a1,a2,…an (-1e9 <= a_i <= 1e9) $ —— 数组的元素

**输出**
输出一个整数，代表 $f(1) + f(2) + … + f(\frac{n}{2} )$ 的最大值

>样例输入
6
6 -8 4 9 11 -10

>样例输出
36

提示
最优方法为 $[6, -8], [4], [9, 11, -10] $

$f(1) = 6 - 8 = -2 $

$f(2) = 2 * (4) = 8$

$f(3) = 3 * (9 + 11 - 10) = 30 $

$f(1) + f(2) + f(3)$ 最大值为 $36$
### 思路
 我们可以通过类似于并查集处理初始值的操作,把每个数都当作一个单独的函数,也就是每个数的系数都是它们本身,这是最坏的情况,然后我们可以通过不断的合并两堆最终把它合并成 $n/2$个堆,我们需要一个维护后缀和的数组,然后对这个数组进行排序,减去前 $n/2$个数即可,至于为什么需要使用维护后缀和的数组,是因为从后面开始合并堆并不会影响前面的数的系数,但是如果从前面开始合并堆,那么会影响后面的数的系数,我们的后缀和数组不能加最后一位,也就是系数为一的那个,系数为一的话再减就没有了,我们减去的后缀和其实就意味着把两堆合并了之后答案中的系数发生的变化,用这种巧妙的办法就可以很好的解决这道题


  ### 代码实现
  ```cpp
  #include <bits/stdc++.h>
   using namespace std;
  #define int long long
   signed main(){
    int n;
    cin >> n;
    vector<int> arr(n);
    int sum = 0;
    for(int i = 0; i < n; i++){
        cin >> arr[i];
        sum += arr[i] * (i + 1);
    }
    vector<int> houzhui;
    int temp = 0;
    for(int i = n-1; i>0; i--){
        houzhui.push_back(arr[i] + temp);
        temp = houzhui.back();
    }
    sort(houzhui.begin(),houzhui.end());
    for (int i = 0;i<n/2;i++){
        sum -= houzhui[i];
    }
    cout << sum;
        return 0;
}
  ```

# 7月8日

 ## 左孩子右孩子
 ### 题目描述
对于一棵多叉树，我们可以通过 “左孩子右兄弟” 表示法，将其转化成一棵二叉树。
如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。
换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。
给定一棵包含 N 个结点的多叉树，结点从 1 至 N 编号，其中 1 号结点是根，每个结点的父结点的编号比自己的编号小。
请你计算其通过 “左孩子右兄弟” 表示法转化成的二叉树，高度最高是多少。
注：只有根结点这一个结点的树高度为0。

**输入描述**
输入的第一行包含一个整数 N。以下N−1​​ 行,每行包含一个整数,依次表示 2 至 N 号结点的父结点编号。

**输出描述**
输出一个整数表示答案。

>输入
5
1
1
1
2

>输出
4

评测用例规模与约定
对于 30%​​ 的评测用例， $1≤N≤20$​；
对于所有评测用例， $1≤N≤100000$。

`运行限制`
`最大运行时间：1s`
`最大运行内存: 256M`
### 题目分析
这道题目并没有真的让我们去建立一个数,我们只需要求出这颗树的高度,而要让这颗树尽可能的高,如图所示,我们要做的就是将输入给出的左边内种样子的树转成右边的样子,这样的高度就是最高的
![1721266551786.png](https://img.picui.cn/free/2024/07/18/669870d7e2a97.png)

所以我们需要让这颗树尽可能的宽,也就是说我们需要让这颗树的每一层都尽可能的多,那么我们可以用一个map来存储每一层的节点,然后我们遍历这个map,找出最大的那一层,就是这颗树的高度。
### 代码实现
```cpp
    #include <bits/stdc++.h>
    using namespace std;
    map<int, vector<int>> mp;
    int f(int x) {
    int maxn = 0;
        for (int i = 0; i < mp[x].size(); i++) {
            maxn = max(maxn, f(mp[x][i]));
        }
        return maxn + mp[x].size();
    }
    int main() {
        int n;
        cin >> n;
        if(n==1){
            cout<<0;
            return 0;
        }
        for (int i = 2; i <= n; i++) {
            int x;
            cin >> x;
            mp[x].push_back(i);
        }
        cout<<f(1)<<endl;
        return 0;
    } 
```
  ## 七段码
  ### 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。

小蓝要用七段码数码管来表示一种特殊的文字。

![七段码](https://doc.shiyanlou.com/courses/uid1580206-20210312-1615527941739)

上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二 极管，分别标记为 $a,b,c,d,e,f,g$。

小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符 的表达时，要求所有发光的二极管是连成一片的。

例如：b 发光，其他二极管不发光可以用来表达一种字符。

例如：c 发光，其他二极管不发光可以用来表达一种字符。这种方案与上 一行的方案可以用来表示不同的字符，尽管看上去比较相似。

例如：a,b,c,d,e 发光，f,g 不发光可以用来表达一种字符。

例如：b,f 发光，其他二极管不发光则不能用来表达一种字符，因为发光 的二极管没有连成一片。

请问，小蓝可以用七段码数码管表达多少种不同的字符？

`运行限制`
`最大运行时间：1s`
`最大运行内存: 128M`
### 题目分析
这道题我们可以用DFS加并查集去做,我们用dfs去枚举每一个数码管的状态，然后用并查集去判断是否是一个连通块，如果是一个连通块，那么这个状态就是一个合法的状态，最后我们统计合法的状态的个数就是答案。
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
bool op[8][8] = {false};
bool vis[8] = {false};
int a[8], ans = 0;
int find(int x) {
    if (x != a[x])
        a[x] = find(a[x]);
    return a[x];
}
void jion(int x, int y) {
    x = find(x);
    y = find(y);
    if (x != y)
        a[x] = y;
    return;
}
bool check() {
    int flag = 0;
    for (int i = 1; i <= 7; i++)
        a[i] = i;
    for (int i = 1; i <= 7; i++) {
        for (int j = 1; j <= 7; j++) {
            if (op[i][j] && vis[i] && vis[j])
                jion(i, j);
        }
    }
    for (int i = 1; i <= 7; i++) {
        if (vis[i] && a[i] == i)
            flag++;
    }
    if (flag == 1)
        return true;
    else
        return false;
}
void dfs(int k) {
    if (k == 8) {
        if (check()) ans++;
        return;
    } else {
        vis[k] = true;
        dfs(k + 1);
        vis[k] = false;
        dfs(k + 1);
    }
}
int main() {
    for (int i = 1; i <= 7; i++) {
        for (int j = 1; j <= 7; j++) {
            if (i == j)
                op[i][j] = true;
        }
    }
    op[1][2] = op[1][6] = true;
    op[2][1] = op[2][3] = op[2][7] = true;
    op[3][4] = op[3][7] = op[3][2] = true;
    op[4][3] = op[4][5] = true;
    op[5][4] = op[5][6] = op[5][7] = true;
    op[6][5] = op[6][1] = op[6][7] = true;
    op[7][2] = op[7][3] = op[7][5] = op[7][6] = true;
    dfs(1);
    cout << ans;
    return 0;
}
```
## 并查集
在刚刚的七段码中,我们用到了并查集,并查集是一种很厉害的数据结构,它可以在$O(1)$的时间复杂度内判断两个元素是否在同一个集合中,并且可以在$O(1)$的时间复杂度内合并两个集合,并查集的基本操作有三个,分别是查找,合并,初始化,并查集的初始化是将每一个元素的父节点指向自己,查找是通过递归的方式找到这个元素的根节点,合并是将两个元素的根节点合并在一起,这样就可以实现并查集的基本操作了.
模板题就是**森林中的鸟**
### 题目描述
一些科学家为森林中成千上万的鸟类拍照。

假设所有出现在同一张照片中的鸟都属于同一棵树。

请你帮助科学家计算森林中树木的最大数量，对于任何一对鸟类，请判断它们是否在同一棵树上。

输入格式
第一行包含整数 N 表示照片数量。

接下来 N 行，每行描述一张照片，格式如下：

$K$   $B_1 B_2 … B_K$
K 表示照片中的鸟的数量，$B_i$ 是鸟的具体编号。

保证所有照片中的鸟被连续编号为 1 到某个不超过 104 的整数。

再一行包含整数 Q。

接下来 Q 行，每行包含两个鸟的编号，表示一组询问。

输出格式
第一行输出最大可能的树的数量以及鸟的数量。

接下来对于每个询问，如果被询问的两个鸟在同一棵树上，则在一行中输出 Yes，否则输出 No。

**数据范围**
$1≤N≤104$,
$1≤K≤10$,
$1≤Q≤104$

>输入：
4
3 10 1 2
2 3 4
4 1 5 7 8
3 9 6 4
2
10 5
3 7

>输出样例
2 10
Yes
No
### 题目分析
这就是并查集模板的裸题,我们只需要跟着并查集模板走就好
这个函数用来查找这个元素的根节点,并且在查找的过程中进行路径压缩
```cpp
int findFather(int x) {
    return father[x] = (x == father[x] ? x : father[x] = findFather(father[x]));
}
```
这个函数实现的是合并的操作,如果两个元素的根节点不同,那么就将这两个元素的根节点合并在一起
```cpp
void merge(int x, int y) {
    int fx = findFather(x);
    int fy = findFather(y);
    if (fx != fy)
        father[fx] = fy;
}
```
这段就是初始化了,将每一个元素的父节点指向自己
```cpp
for (int i = 1; i <= P; i++) {
        father[i] = i;
    }
```
那么一个并查集板子就做好了,我们只需要根据题目的要求去实现就好了
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxN = 10010;
int father[maxN], bird[maxN];
int findFather(int x) {
    return father[x] = (x == father[x] ? x : father[x] = findFather(father[x]));
}
void merge(int x, int y) {
    int fx = findFather(x);
    int fy = findFather(y);
    if (fx != fy)
        father[fx] = fy;
}
int main() {
    int P, Q, N;
    cin >> P;
    for (int i = 1; i <= P; i++) {
        father[i] = i;
    }
    int cntBird = 0;
    for (int i = 1; i <= P; i++) {
        cin >> N;
        for (int j = 0; j < N; j++) {
            int indices;
            cin >> indices;
            if (bird[indices] == 0) {
                bird[indices] = i;
                cntBird++;
            }
            if (bird[indices] != 1) {
                merge(i, bird[indices]);
            }
        }
    }
    int cntTree = 0;
    for (int i = 1; i <= cntBird; i++) {
        if (father[i] == i) {
            cntTree++;
        }
    }
    cout << cntTree << " " << cntBird << endl;
    cin >> Q;
    for (int i = 0; i < Q; i++) {
        int bird1 = 0, bird2 = 0;
        cin >> bird1 >> bird2;
        if (findFather(bird1) == findFather(bird2)) {
            cout << "Yes" << endl;
        } else {
            cout << "No" << endl;
        }
    }
}
```

# 7月9日
## 包子凑数
### 题目描述
小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 N 种蒸笼，其中第 i 种蒸笼恰好能放 Ai 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 X 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 X 个包子。比如一共有 3 种蒸笼，分别能放 3、4 和 5 个包子。当顾客想买 11 个包子时，大叔就会选 2 笼 3 个的再加 1 笼 5 个的（也可能选出 1 笼 3 个的再加 2 笼 4 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 3 种蒸笼，分别能放 4、5 和 6 个包子。而顾客想买 7 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

**输入描述**
第一行包含一个整数 N $(1≤N≤100)$。



**输出描述**
一个整数代表答案。如以下 N 行每行包含一个整数 $A_i(1≤A_i≤100)$。果凑不出的数目有无限多个，输出 `INF`。

>输入
2
4
5

>输出
6

>样例说明
凑不出的数目包括：1, 2, 3, 6, 7, 11。
___


>输入
2
4
6

>输出
INF

>样例说明
所有奇数都凑不出来，所以有无限多个

`运行限制`
`最大运行时间：1s`
`最大运行内存: 256M`

### 题目分析
这道题目有一个很大的误导,就是它能凑出来的数跟他的奇数偶数是没有关系的,事实上,只要这些数的最大公约数不是1,也就是说它们不互质,那么就会有无限多个数凑不出来.
那么对于互质的数,我们可以先打表看看怎么个事
拿样例4,5举例:
$1,2,3$拿不出来
$4=4*1+5*0$
$5=4*0+5*1$
$6,7$拿不出来
$8=4*2+5*0$
$9=4*1+5*1$
$10=4*0+5*2$
$11$拿不出来
$12=4*3+5*0$
$13=4*2+5*1$
$14=4*1+5*2$
$15=4*0+5*3$
$16=4*4+5*0$
$17=4*3+5*1$
$18=4*2+5*2$
$19=4*1+5*3$
$20=4*0+5*4$
依此类推,后面的数我们也可以通过用前面的数加上我们刚推出来的数得到,我们可以发现,当顾客要的包子的数量大于一定数时,它一定能给出来,那么这个一定的数怎么找呢,它其实是$a*b-a-b+1$. 那么我们就可以给这个数组定边界了, 
`以下 N 行每行包含一个整数 $A_i(1≤A_i≤100)$`。
所以我们的边界不可能超过10000
然后就是寻找这道题的状态转移方程了,我们可以用dp[i]表示我们能否凑出i个包子,那么我们可以用$dp[j]$来更新$dp[j+a[i]]$.
最后我们只要统计一下dp数组中有多少个0就可以了.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int a, int b) {
    while (b ^= a ^= b ^= a %= b)
        ;
    return a;
}
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    int flag = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        flag = gcd(flag, a[i]);
    }
    if (flag != 1) {
        cout << "INF" << endl;
        return 0;
    }
    vector<int> dp(10005, 0);
    dp[0] = 1;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = a[i]; j < 10005; j++) {
            dp[j] = max(dp[j], dp[j - a[i]]);
        }
    }
    for (int i = 1; i < 10005; i++) {
        if (!dp[i]) {
            cnt++;
        }
    }
    cout << cnt << endl;
    return 0;
}
```
## 第几个幸运数字
### 题目描述
**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

到 X 星球旅行的游客都被发给一个整数，作为游客编号。X 星的国王有个怪癖，他只喜欢数字 3,5 和 7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。我们来看前10 个幸运数字是：`3579152125273545` 因而第 11 个幸运数字是：49 小明领到了一个幸运数字` 59084709587505`，他去领奖的时候，人家要求他准确地说出这是第几个幸运数字，否则领不到奖品。

请你帮小明计算一下，

59084709587505 是第几个幸运数字。

`运行限制`
`最大运行时间：1s`
`最大运行内存: 128M`

### 题目分析
我们直接暴力就好,遍历所有3,5,7的幂次方的乘积,然后判断是否小于59084709587505,如果小于,那么我们就可以得到一个幸运数字,最后我们统计一下就可以了.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int cnt = 0;
    int ans = 59084709587505;
    for (int i = 0; pow(7, i) <= ans; i++) {
        for (int j = 0; pow(5, j) <= ans; j++) {
            for (int k = 0; pow(3, k) <= ans; k++) {

                if (pow(3, k) * pow(5, j) * pow(7, i) < ans)
                    cnt++;
            }
        }
    }
    cout << cnt << endl;
    return 0;
}
```

# 7月10日
## 外卖店优先级
### 题目描述
“饱了么”外卖系统中维护着 𝑁 家外卖店，编号 1 ∼ 𝑁。每家外卖店都有 一个优先级，初始时 (0 时刻) 优先级都为 0。
每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减 到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。
如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果 优先级小于等于 3，则会被清除出优先缓存。
给定 𝑇 时刻以内的 𝑀 条订单信息，请你计算 𝑇 时刻时有多少外卖店在优 先缓存中?
**输入描述**
第一行包含 3 个整数 $N,M,T$
以下 M 行每行包含两个整数 ts,id，表示 ts 时刻编号 id 的外卖店收到一个订单。

其中，$1<=N,M,T<=10^5,1<=ts<=T,1<=id<=N$

**输出描述**
输出一个整数表示答案

>输入
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2

>输出
1

>样例解释：
6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6， 加入优先缓存。所以是有 1 家店 (2 号) 在优先缓存中。

`运行限制`
`最大运行时间：2s`
`最大运行内存: 256M`
### 题目分析
这是一道大模拟题,不难但是要很细心,做的时候要注意时间的流逝,以及优先级的变化,这里我们可以用一个数组来存储每家店的优先级,然后用一个set来存储优先级大于5的店,每次有订单的时候,我们就将这家店的优先级加2,然后判断是否大于5,如果大于5就加入set,如果小于等于3就从set中删除,然后每次时间流逝的时候,我们就将优先级小于等于3的店从set中删除,这样就可以得到答案了.
在做这道题的时候,有几个点卡了我许久,一个是我没有处理在输入结束时候的情况,另一个是我并没有在它的优先级小于等于3的时候立马删除,而是等到时间流逝的时候才删除,这样就会导致在时间流逝的时候,这家店的优先级又变成了大于5,这样就会导致错误的结果.

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, m, t;
    cin >> n >> m >> t;
    vector<int> a(n + 1, 0);
    vector<pair<int, int>> b(m+1);
    for (int i = 1; i <= m; i++) {
        cin >> b[i].first >> b[i].second;
    }
    sort(b.begin(), b.end(),
         [](pair<int, int> x, pair<int, int> y) { return x.first < y.first; });
    int time = 0;
    set<int> q;
    vector<bool> flag(n, false);
    for (int i = 1; i <= m; i++) {
        // cout<<a[1]<<" "<<a[2]<<endl;
        // cout << time << endl;
        if (b[i].first == time) {
            // cout << b[i].second << " " << a[b[i].second] << endl;
            a[b[i].second] += 2;
            flag[b[i].second] = true;
            if (a[b[i].second] > 5&&!q.count(b[i].second)) {
                q.insert(b[i].second);
            }
        }
        if(i==m){
            for (int j = 1; j <= n; j++) {
                if (!flag[j] && a[j] > 0) {
                    a[j]--;
                    if(a[j]<=3&&q.count(j)){
                        q.erase(j);
                    }
                }
            }
        }
        if (b[i].first > time) {
            time++;
            for (int j = 1; j <= n; j++) {
                if (!flag[j] && a[j] > 0) {
                    a[j]--;
                    if(a[j]<=3&&q.count(j)){
                        q.erase(j);
                    }
                }
                flag[j] = false;
            }
            i--;
        }
       
    }
    cout << q.size()<< endl;
    return 0;
}
```
## 修改数组
### 题目描述
给定一个长度为 𝑁 的数组 $𝐴=[𝐴_1,𝐴_2,⋅⋅⋅,𝐴_𝑁]$，数组中有可能有重复出现的整数。

现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改$𝐴_2,𝐴_3,⋅⋅⋅,𝐴_𝑁$。

当修改 $𝐴_𝑖 $时，小明会检查 $𝐴_𝑖$ 是否在 𝐴1∼ 𝐴𝑖−1中出现过。如果出现过，则小明会给 $𝐴_𝑖$ 加上 1 ；如果新的 $𝐴_i$ 仍在之前出现过，小明会持续给 $𝐴_𝑖$ 加 1 ，直 到 $𝐴_𝑖$ 没有在 $𝐴_1 ∼ 𝐴_{𝑖−1}$ 中出现过。

当 𝐴𝑁 也经过上述修改之后，显然 𝐴 数组中就没有重复的整数了。

现在给定初始的 𝐴 数组，请你计算出最终的 𝐴 数组。

输入描述
第一行包含一个整数 𝑁。

第二行包含 𝑁 个整数，$A_1,A_2…,A_N$。

其中，$1 \leq N \leq 10^5,，1 \leq A_i \leq 10^6$

输出描述
输出 𝑁 个整数，依次是最终的 $A_1,A_2…A_N$。

>输入
5
2 1 1 3 4

>输出
2 1 3 4 5

`运行限制`
`最大运行时间：1s`
`最大运行内存: 256M`

### 题目分析
 先分析一下题目,这道题的意思就是让我们把数组中重复的数变得不在重复,方式就是不断加,加到这道数当前在数组中没有为止
这道题的正解是并查集,但一开始我并没有使用并查集,而是模拟题意暴力寻找,在第一遍提交的时候只收获了80分,然后我加上了快读,收获了90分;
**90分代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n;
    n = read();
    vector<int> a(n);
    vector<int> b(1000000, 0);
    for (int i = 0; i < n; i++) {
        a[i]=read();
    }
    for (int i = 0; i < n; i++) {
        b[a[i]]++;
        if (b[a[i]] > 1) {
          b[a[i]]--;
          auto it = find(b.begin()+a[i], b.end(), 0);
          *it = 1;
            a[i] = it - b.begin();
        }
        cout << a[i] << " ";
    }
    return 0;
}
```
这道题的正解我们需要用到并查集的折叠查询的思想,在find函数中使用路径压缩,让子节点的父亲直接指向根节点,然后在没有找到的时候,我们就将这个数的父亲指向这个数+1,这样就可以得到答案了

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int father[100000];
int findFather(int x) {
    if (father[x] == 0) {
        father[x] = x + 1;
        return x;
    } else {
        return father[x] = findFather(father[x]);
    }
}
int main() {
    int n;
    cin >> n;
    vector<int> a(n);
    vector<int> b(1000000, 0);
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        cout << findFather(x) << " ";
    }
    return 0;
}
```

# 7月11日
## 作物杂交
### 题目描述
作物杂交是作物栽培中重要的一步。已知有 𝑁 种作物 (编号 1 至 𝑁)，第 𝑖 种作物从播种到成熟的时间为 𝑇𝑖。作物之间两两可以进行杂交，杂交时间取两种中时间较长的一方。如作物 A 种植时间为 5 天，作物 B 种植时间为 7 天，则 AB 杂交花费的时间为 7 天。作物杂交会产生固定的作物，新产生的作物仍然属于 𝑁 种作物中的一种。

初始时，拥有其中 𝑀 种作物的种子 (数量无限，可以支持多次杂交)。同时可以进行多个杂交过程。求问对于给定的目标种子，最少需要多少天能够得到。

如存在 4 种作物 ABCD，各自的成熟时间为 5 天、7 天、3 天、8 天。初始拥有 AB 两种作物的种子，目标种子为 D，已知杂交情况为 $A \times B \rightarrow  C$，$A \rightarrow  C → D$。则最短的杂交过程为：

第 1 天到第 7 天 (作物 B 的时间)，$A \times B \rightarrow  C$。

第 8 天到第 12 天 (作物 A 的时间)，$A \times C \rightarrow  D$。

花费 12 天得到作物 D 的种子。

**输入描述**
输入的第 1 行包含 4 个整数 $N,M,K,T$，$N$ 表示作物种类总数 (编号 $1$ 至 $N$)，$M$ 表示初始拥有的作物种子类型数量，$K$ 表示可以杂交的方案数，$T$ 表示目标种子的编号。

第 2 行包含 N 个整数，其中第 i 个整数表示第 i 种作物的种植时间 
$𝑇_𝑖(1≤T_i ≤100)$。

第 3 行包含 M 个整数，分别表示已拥有的种子类型 $𝐾_𝑗(1≤K_j≤M)$，
K_j两两不同。

第 4 至 $K + 3$ 行，每行包含 3 个整数 A,B,C，表示第 A 类作物和第 B 类作物杂交可以获得第 C 类作物的种子。其中，$1≤N≤2000,2≤M≤N,1≤K≤10^5,1≤T≤N$, 保证目标种子一定可以通过杂交得到。

**输出描述**
输出一个整数，表示得到目标种子的最短杂交时间。

>输入
6 2 4 6
5 3 4 6 4 9
1 2
1 2 3
1 3 4
2 3 5
4 5 6

>输出
16

>样例说明
第 1 天至第 5 天，将编号 1 与编号 2 的作物杂交，得到编号 3 的作物种子。
第 6 天至第 10 天，将编号 1 与编号 3 的作物杂交，得到编号 4 的作物种子。
第 6 天至第 9 天，将编号 2 与编号 3 的作物杂交，得到编号 5 的作物种子。
第 11 天至第 16 天，将编号 4 与编号 5 的作物杂交，得到编号 6 的作物种子。
总共花费 16 天。

`运行限制`
`最大运行时间：2s`
`最大运行内存: 256M`

### 题目分析
这道题的核心是求最短路径,我们可以把作物看作是图中的点,杂交看作是边,然后求最短路径,这里我们可以用dijkstra算法来求解.我们遍历所有杂交方案，检查父本是否存在且产物的最短时间未确定,然后计算杂交所需时间和最早开始时间，更新产物的最短时间（如果更优）。循环结束代表找到本轮杂交后仍未确定最短时间但时间最短的物种
我们通过迭代的方式，通过贪心逐步更新并确定每个农作物的最短获得时间，直到找到目标物种的最短路径。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2020;
int n, m, k, t;
int a[N];
vector<pair<int, int>> g[N];
bool st[N], backup[N];
int d[N];
pair<int, int> p[N];

int main() {
    memset(d, 0x3f3f3f3f, sizeof d);
    cin >> n >> m >> k >> t;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++) {
        int x;
        cin >> x;
        st[x] = true;
        d[x] = 0;
    }
    for (int i = 0; i < k; i++) {
        int x, y, a;
        cin>>x>>y>>a;
        g[a].push_back(make_pair(x, y));
    }

    for (int i = 1; i <= n; i++)
        for (int j = 0; j < (int)g[i].size(); j++)
            if (st[g[i][j].first] && st[g[i][j].second]) {
                int rd = d[i];
                d[i] = min(d[i], max(a[g[i][j].first], a[g[i][j].second]));
                if (d[i] < rd)
                    p[i] = make_pair(g[i][j].first, g[i][j].second);
            }

    for (int i = 1; i <= n; i++) {
        int minv = 0x3f3f3f3f;
        int v;
        for (int j = 1; j <= n; j++) {
            if (!st[j] && d[j] < minv) {
                v = j;
                minv = d[j];
            }
        }
        st[v] = true;

        for (int j = 1; j <= n; j++)
            for (int l = 0; l < (int)g[j].size(); l++)
                if (!st[j] && st[g[j][l].first] && st[g[j][l].second]) {
                    int rd = d[j];
                    d[j] = min(d[j],
                               max(a[g[j][l].first], a[g[j][l].second]) + d[v]);
                    if (d[j] < rd)
                        p[j] = make_pair(g[j][l].first, g[j][l].second);
                }
    }

    cout << d[t] << endl;

    return 0;
}
```
## 出租车


### 题目背景

小蓝在 $L$ 市开出租车。

### 题目描述

$L$ 市的规划很规整，所有的路都是正东西向或者正南北向的，道路都可以看成直线段。东西向的道路互相平行, 南北向的道路互相平行，任何一条东西向道路垂直于任何一条南北向道路。

从北到南一共有 $n$ 条东西向道路，依次标号为 $H_{1}, H_{2}, \cdots, H_{n}$ 。从西到东 一共有 $m$ 条南北向的道路，依次标号为 $S_{1}, S_{2}, \cdots, S_{m}$ 。

每条道路都有足够长，每一条东西向道路和每一条南北向道路都相交，$H_{i}$ 与 $S_{j}$ 的交叉路口记为 $(i, j)$ 。

从 $H_{1}$ 和 $S_{1}$ 的交叉路口 $(1,1)$ 开始，向南遇到的路口与 $(1,1)$ 的距离分别 是 $h_{1}, h_{2}, \cdots, h_{n-1}$，向东遇到路口与 $(1,1)$ 的距离分别是 $w_{1}, w_{2}, \cdots, w_{m-1}$ 。

道路的每个路口都有一个红绿灯。

时刻 $0$ 的时候，南北向绿灯亮，东西向红灯亮，南北向的绿灯会持续一段时间（每个路口不同)，然后南北向变成红灯，东西向变成绿灯，持续一段时间后，再变成南北向绿灯，东西向红灯。

已知路口 $(i, j)$ 的南北向绿灯每次持续的时间为 $g_{i j}$, 东西向的绿灯每次持续的时间为 $r_{i j}$, 红绿灯的变换时间忽略。

当一辆车走到路口时，如果是绿灯，可以直行、左转或右转。如果是红灯，可以右转，不能直行或左转。如果到路口的时候刚好由红灯变为绿灯，则视为看到绿灯；如果刚好由绿灯变为红灯，则视为看到红灯。

每段道路都是双向道路，道路中间有隔离栏杆，在道路中间不能掉头, 只能在红绿灯路口掉头。掉头时不管是红灯还是绿灯都可以直接掉头。掉头的时间可以忽略。

小蓝时刻 $0$ 从家出发。今天，他接到了 $q$ 个预约的订单，他打算按照订单 的顺序依次完成这些订单，就回家休息。中途小蓝不准备再拉其他乘客。小蓝的家在两个路口的中点，小蓝喜欢用 $x_{1}, y_{1}, x_{2}, y_{2}$ 来表示自己家的位 置, 即路口 $\left(x_{1}, y_{1}\right)$ 到路口 $\left(x_{2}, y_{2}\right)$ 之间的道路中点的右侧, 保证两个路口相邻 (中间没有其他路口)。请注意当两个路口交换位置时，表达的是路的不同两边，路中间有栏杆，因此这两个位置实际要走比较远才能到达。

小蓝的订单也是从某两个路口间的中点出发，到某两个路口间的中点结束。小蓝必须按照给定的顺序处理订单，而且一个时刻只能处理一个订单，不能图省时间而同时接两位乘客，也不能揷队完成后面的订单。

小蓝只对 $L$ 市比较熟，因此他只会在给定的 $n$ 条东西向道路和 $m$ 条南北向道路上行驶，而且不会驶出 $H_{1}, H_{n}, S_{1}, S_{m}$ 这几条道路所确定的矩形区域 可以到边界。

小蓝行车速度一直为 $1$，乘客上下车的时间忽略不计。

请问，小蓝最早什么时候能完成所有订单回到家。

### 输入格式

输入第一行包含两个整数 $n, m$，表示东西向道路的数量和南北向道路的数 量。

第二行包含 $n-1$ 个整数 $h_{1}, h_{2}, \cdots, h_{n-1}$ 。

第三行包含 $m-1$ 个整数 $w_{1}, w_{2}, \cdots, w_{m-1}$ 。

接下来 $n$ 行, 每行 $m$ 个整数，描述每个路口南北向绿灯的时间，其中的第 $i$ 行第 $j$ 列表示 $g_{i j}$ 。

接下来 $n$ 行, 每行 $m$ 个整数，描述每个路口东西向绿灯的时间，其中的第 $i$ 行第 $j$ 列表示 $r_{i j}$ 。

接下来一行包含四个整数 $x_{1}, y_{1}, x_{2}, y_{2}$，表示小蓝家的位置在路口 $\left(x_{1}, y_{1}\right)$ 到路口 $\left(x_{2}, y_{2}\right)$ 之间的道路中点的右侧。

接下来一行包含一个整数 $q$，表示订单数量。

接下来 $q$ 行，每行描述一个订单，其中第 $i$ 行包含八个整数 $x_{i 1}, y_{i 1}, x_{i 2}, y_{i 2}$，$x_{i 3}, y_{i 3}, x_{i 4}, y_{i 4}$，表示第 $i$ 个订单的起点为路口 $\left(x_{i 1}, y_{i 1}\right)$ 到路口 $\left(x_{i 2}, y_{i 2}\right)$ 之间的道 路中点的右侧，第 $i$ 个订单的终点为路口 $\left(x_{i 3}, y_{i 3}\right)$ 到路口 $\left(x_{i 4}, y_{i 4}\right)$ 之间的道路中 点的右侧。

### 输出格式

输出一个实数，表示小蓝完成所有订单最后回到家的最早时刻。四舍五入保留一位小数。

### 样例 #1

### 样例输入 #1

```
2 3
200
100 400
10 20 10
20 40 30
20 20 20
20 20 20
2 1 1 1
1
2 2 1 2 1 2 1 3
```

### 样例输出 #1

```
1620.0
```

### 提示

**【样例说明】**

蓝有一个订单, 他的行车路线如下图所示。其中 $\mathrm{H}$ 表示他家的位置, $\mathrm{S}$ 表示订单的起点, $\mathrm{T}$ 表示订单的终点。小小明在最后回家时要在直行的红绿灯路 口等绿灯, 等待时间为 $20$。 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_334c51de49a3a8e7ba1bg-15.jpg)

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例, $1 \leq n, m \leq 5,1 \leq q \leq 10$ 。

对于 $50 \%$ 的评测用例, $1 \leq n, m \leq 30,1 \leq q \leq 30$ 。

对于所有评测用例, $1 \leq n, m \leq 100,1 \leq q \leq 30,1 \leq h_{1}<h_{2}<\cdots<h_{n-1} \leq$ $100000,1 \leq w_{1}<w_{2}<\cdots<w_{m-1} \leq 100000,1 \leq g_{i j} \leq 1000,1 \leq r_{i j} \leq 1000$, 给定的路口一定合法。

### 题目分析
~~别看这道题这么长,其实它一点也不简单~~,洛谷给难度定为了蓝题,核心做法是dijstra算法加堆优化
![1721273578037.png](https://img.picui.cn/free/2024/07/18/66988c48b66be.png)
 我们找最短路的时候不能简单的把顶点看作是路口, 而是要把起始点和终点定为两个路口之间的中点,然后再dij找最短路的时候模拟车辆遇到红绿灯的情况
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Pos {
    int index;
    double value;
    Pos(int i, double v) : index(i), value(v) {}
    bool operator<(const Pos &r) const { return value > r.value; }
};
int n, m;
int h[105], w[105];
int g[105][105], r[105][105];
int map(int x1, int y1, int x2, int y2) {
    if (x1 == x2 && y1 < y2)
        return (x1 - 1) * (m - 1) + y1 - 1;
    if (x1 == x2 && y1 > y2)
        return (x1 - 1) * (m - 1) + y2 - 1 + n * (m - 1);
    if (x1 < x2 && y1 == y2)
        return (x1 - 1) * m + y1 - 1 + 2 * n * (m - 1);
    if (x1 > x2 && y1 == y2)
        return (x2 - 1) * m + y1 - 1 + 2 * n * (m - 1) + (n - 1) * m;
}
double cal_time(int x1, int y1, int x2, int y2, double cur_t, int op) {
    if (op == 0) // 调头
    {
        if (x1 == x2)
            return w[y1 < y2 ? y1 : y2];
        else
            return h[x1 < x2 ? x1 : x2];
    }
    if (op == 1) // 右转
    {
        if (x1 == x2 && y1 < y2) // 西向东转北向南
            return w[y1] * 0.5 + h[x1] * 0.5;
        if (x1 == x2 && y1 > y2) // 东向西转南向北
            return w[y2] * 0.5 + h[x1 - 1] * 0.5;
        if (x1 < x2 && y1 == y2) // 北向南转东向西
            return w[y1 - 1] * 0.5 + h[x1] * 0.5;
        if (x1 > x2 && y1 == y2) // 南向北转西向东
            return w[y1] * 0.5 + h[x2] * 0.5;
    }
    if (op == 2) // 直行
    {
        double time;
        if (x1 == x2) {
            if (y1 < y2) {
                time = fmod(w[y1] * 0.5 + cur_t, g[x1][y2] + r[x1][y2]);
                if (time >= g[x1][y2])
                    time = 0;
                else
                    time = g[x1][y2] - time;
                return w[y1] * 0.5 + w[y2] * 0.5 + time;
            } else {
                time = fmod(w[y2] * 0.5 + cur_t, g[x1][y2] + r[x1][y2]);
                if (time >= g[x1][y2])
                    time = 0;
                else
                    time = g[x1][y2] - time;
                return w[y2] * 0.5 + w[y2 - 1] * 0.5 + time;
            }
        } else {
            if (x1 < x2) {
                time = fmod(h[x1] * 0.5 + cur_t, g[x2][y1] + r[x2][y1]);
                if (time < g[x2][y1])
                    time = 0;
                else
                    time = g[x2][y1] + r[x2][y1] - time;
                return h[x1] * 0.5 + h[x2] * 0.5 + time;
            } else {
                time = fmod(h[x2] * 0.5 + cur_t, g[x2][y1] + r[x2][y1]);
                if (time < g[x2][y1])
                    time = 0;
                else
                    time = g[x2][y1] + r[x2][y1] - time;
                return h[x2] * 0.5 + h[x2 - 1] * 0.5 + time;
            }
        }
    }
    if (op == 3) // 左转
    {
        double time;
        if (x1 == x2 && y1 < y2) // 西向东转南向北
        {
            time = fmod(w[y1] * 0.5 + cur_t, g[x1][y2] + r[x1][y2]);
            if (time >= g[x1][y2])
                time = 0;
            else
                time = g[x1][y2] - time;
            return w[y1] * 0.5 + h[x1 - 1] * 0.5 + time;
        }
        if (x1 == x2 && y1 > y2) // 东向西转北向南
        {
            time = fmod(w[y2] * 0.5 + cur_t, g[x1][y2] + r[x1][y2]);
            if (time >= g[x1][y2])
                time = 0;
            else
                time = g[x1][y2] - time;
            return w[y2] * 0.5 + h[x1] * 0.5 + time;
        }

        if (x1 < x2 && y1 == y2) // 北向南转西向东
        {
            time = fmod(h[x1] * 0.5 + cur_t, g[x2][y1] + r[x2][y1]);
            if (time < g[x2][y1])
                time = 0;
            else
                time = g[x2][y1] + r[x2][y1] - time;
            return w[y1] * 0.5 + h[x1] * 0.5 + time;
        }

        if (x1 > x2 && y1 == y2) // 南向北转东向西
        {
            time = fmod(h[x2] * 0.5 + cur_t, g[x2][y1] + r[x2][y1]);
            if (time < g[x2][y1])
                time = 0;
            else
                time = g[x2][y1] + r[x2][y1] - time;
            return w[y1 - 1] * 0.5 + h[x2] * 0.5 + time;
        }
    }
}
void setxy(int *x1, int *y1, int *x2, int *y2, int cur) {
    if (cur < n * (m - 1)) {
        *x1 = *x2 = cur / (m - 1) + 1;
        *y1 = cur % (m - 1) + 1;
        *y2 = *y1 + 1;
    } else {
        cur -= n * (m - 1);
        if (cur < n * (m - 1)) {
            *x1 = *x2 = cur / (m - 1) + 1;
            *y2 = cur % (m - 1) + 1;
            *y1 = *y2 + 1;
        } else {
            cur -= n * (m - 1);
            if (cur < (n - 1) * m) {
                *x1 = cur / m + 1;
                *x2 = *x1 + 1;
                *y1 = *y2 = cur % m + 1;
            } else {
                cur -= (n - 1) * m;
                *x2 = cur / m + 1;
                *x1 = *x2 + 1;
                *y1 = *y2 = cur % m + 1;
            }
        }
    }
}
double dj(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4,
          double t) {
    int flag[2 * (n * (m - 1) + (n - 1) * m)];
    double dist[2 * (n * (m - 1) + (n - 1) * m)];
    memset(flag, 0, sizeof(int) * 2 * (n * (m - 1) + (n - 1) * m));
    memset(dist, 0, sizeof(double) * 2 * (n * (m - 1) + (n - 1) * m));
    int cur = map(x1, y1, x2, y2), to;
    priority_queue<Pos> q;
    // q.push(Pos(cur,0));
    double min_dist;
    flag[cur] = 1; // printf("%d map\n",cur);
    while (1) {
        double next_dist;
        // 调头
        to = map(x2, y2, x1, y1);
        next_dist = cal_time(x1, y1, x2, y2, dist[cur] + t, 0);
        if (!flag[to] && (!dist[to] || dist[cur] + next_dist < dist[to])) {
            dist[to] = dist[cur] + next_dist;
            q.push(Pos(to, dist[to]));
        }
        // 右转
        to = -1;
        if (x1 == x2 && y1 < y2 && x1 < n)
            to = map(x1, y2, x1 + 1, y2);
        if (x1 == x2 && y1 > y2 && x1 > 1)
            to = map(x1, y2, x1 - 1, y2);
        if (x1 < x2 && y1 == y2 && y1 > 1)
            to = map(x2, y1, x2, y1 - 1);
        if (x1 > x2 && y1 == y2 && y1 < m)
            to = map(x2, y1, x2, y1 + 1);
        if (to != -1) {
            next_dist = cal_time(x1, y1, x2, y2, dist[cur] + t, 1);
            if (!flag[to] && (!dist[to] || dist[cur] + next_dist < dist[to])) {
                dist[to] = dist[cur] + next_dist;
                q.push(Pos(to, dist[to]));
            }
        }
        // 直行
        to = -1;
        if (x1 == x2 && y1 < y2 && y2 < m)
            to = map(x1, y2, x1, y2 + 1);
        if (x1 == x2 && y1 > y2 && y2 > 1)
            to = map(x1, y2, x1, y2 - 1);
        if (x1 < x2 && y1 == y2 && x2 < n)
            to = map(x2, y1, x2 + 1, y1);
        if (x1 > x2 && y1 == y2 && x2 > 1)
            to = map(x2, y1, x2 - 1, y1);
        if (to != -1) {
            next_dist = cal_time(x1, y1, x2, y2, dist[cur] + t, 2);
            if (!flag[to] && (!dist[to] || dist[cur] + next_dist < dist[to])) {
                dist[to] = dist[cur] + next_dist;
                q.push(Pos(to, dist[to]));
            }
        }
        // 左转
        to = -1;
        if (x1 == x2 && y1 < y2 && x1 > 1)
            to = map(x1, y2, x1 - 1, y2);
        if (x1 == x2 && y1 > y2 && x1 < n)
            to = map(x1, y2, x1 + 1, y2);
        if (x1 < x2 && y1 == y2 && y1 < m)
            to = map(x2, y1, x2, y1 + 1);
        if (x1 > x2 && y1 == y2 && y1 > 1)
            to = map(x2, y1, x2, y1 - 1);
        if (to != -1) {
            next_dist = cal_time(x1, y1, x2, y2, dist[cur] + t, 3);
            if (!flag[to] && (!dist[to] || dist[cur] + next_dist < dist[to])) {
                dist[to] = dist[cur] + next_dist;
                q.push(Pos(to, dist[to]));
            }
        }
        cur = q.top().index;
        min_dist = q.top().value;
        q.pop();
        setxy(&x1, &y1, &x2, &y2, cur);
        // printf("%f %d %d %d %d %d pos\n"
        // ,min_dist, cur,x1,y1,x2,y2);

        if (x1 == x3 && y1 == y3 && x2 == x4 && y2 == y4) {
            return min_dist;
        }

        else
            flag[cur] = 1;
    }
}

int main() {
    int i, j;
    scanf("%d%d", &n, &m);
    for (i = 1; i <= n - 1; i++)
        scanf("%d", &h[i]);
    for (i = n - 1; i >= 2; i--)
        h[i] -= h[i - 1];

    for (i = 1; i <= m - 1; i++)
        scanf("%d", &w[i]);
    for (i = m - 1; i >= 2; i--)
        w[i] -= w[i - 1];
    for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            scanf("%d", &g[i][j]);
    for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            scanf("%d", &r[i][j]);
    int x1, y1, x2, y2, tx1, ty1, tx2, ty2;
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    tx1 = x1, ty1 = y1, tx2 = x2, ty2 = y2;
    int q;
    double re = 0;
    scanf("%d", &q);
    int xi1, yi1, xi2, yi2, xi3, yi3, xi4, yi4;
    while (q--) {
        scanf("%d%d%d%d", &xi1, &yi1, &xi2, &yi2);
        re += dj(x1, y1, x2, y2, xi1, yi1, xi2, yi2, re);
        // printf("%fre\n",re);
        scanf("%d%d%d%d", &xi3, &yi3, &xi4, &yi4);
        re += dj(xi1, yi1, xi2, yi2, xi3, yi3, xi4, yi4, re);
        x1 = xi3, y1 = yi3, x2 = xi4, y2 = yi4;
    }
    re += dj(xi3, yi3, xi4, yi4, tx1, ty1, tx2, ty2, re);
    printf("%.1f\n", re);
}
```

# 7月12日
<big>今天讲了昨天校赛的题</big>
## 扶老奶奶过马路
`内存限制：128 MB
时间限制：1.000 S
评测方式：文本比较`

### 题目描述
有一群小朋友扶一群老奶奶过马路，但小朋友只记住了扶老奶奶过马路是“做好事”，却忽略了老奶奶是否有过马路的真实需求。 就出现了，把老奶奶扶过去，又扶回来的情况。 假设，有N位老奶奶站在马路东侧，编号1至N，第1分钟，把所有编号能够被1整除的老奶奶扶到马路对面（即所有老奶奶从东侧到西侧，因为所有数被1除，都余0）； 第2分钟，把所有编号能够被2整除的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧，例如2号老奶奶，第1分钟被从东扶到西，第2分钟又被扶着回来）； 第3分钟，把所有编号能够被3整除的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧）；$\cdots \cdots$； 第N分钟，把所有能够被N整除编号的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧）； 问:最后，马路东侧有多少老奶奶，即多少老奶奶没有过马路？
**输入**
输入有两行： 

第一行为测试案例的个数$M$；

第二行是M个整数，每个整数对应一个测试数据的N。$(1 \leq N \leq 10^9)$

输出
你的输出应该有$M$行，每行一个整数，表示与输入对应的答案

>样例输入
2
1 5

>样例输出
0
3

>提示
以N=5为例，第1分钟，1、2、3、4、5从东到西;第2分钟，2、4从西到东；第3分钟，3从西到东；第4分钟，4从东到西；第5分钟，5从西到东；最后，2、3、5在东侧，1、4在西侧。

### 题目分析
这道题比赛的时候真是难倒我了
我一直都找不出它的规律,尤其是在老师说它的核心代码超过三行都算失败的时候,我找规律的思路一开始就歪了,因为我一直都在往分解素因子内方面想,知道我模拟了十个人过马路的时候,我才看出来原来马路右边的也就是不选的是1,2,4,9,也就是平方数,但是遍历去平方数会超时,于是简单推导一下他的公式吧,很简单就可以得到
$$ A=x-\left\lfloor\sqrt{x}  \right\rfloor $$

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n;
    cin >> n;
    while (n--) {
        int a;
        cin >> a;
        int ans =sqrt(a);
        cout << a-ans << endl;
    }
    return 0;
}
```
### 拓展联想
写完我才发现,这不是开关灯吗 题目在这里
## 开灯

### 题目背景

该题的题目是不是感到很眼熟呢?

事实上，如果你懂的方法，该题的代码简直不能再短。

但是如果你不懂得呢？那。。。（自己去想）

### 题目描述

首先所有的灯都是关的（注意是关！），编号为 $1$ 的人走过来，把是 $1$ 的倍数的灯全部打开，编号为 $2$ 的人把是 $2$ 的倍数的灯全部关上，编号为 $3$ 的人又把是 $3$ 的倍数的灯开的关上，关的开起来……直到第 $N$ 个人为止。

给定 $N$，求 $N$ 轮之后，还有哪几盏是开着的。

### 输入格式

一个数 $N$，表示灯的个数和操作的轮数。

### 输出格式

若干数，表示开着的电灯编号。

### 样例 #1

#### 样例输入 #1

```
5
```

#### 样例输出 #1

```
1 4
```

### 提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le N \le 2^{40}$。

**【其他说明】**

数学题！
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for (int i = 1; i <= sqrt(n);i++){
        cout << i * i << " ";
    }
        return 0;
}
```
写过的题想半天是真的很令人难受
## xc的game
`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
小胡和小周在玩游戏，游戏的规则如下：现在有 2 堆石子，各有 a，b 颗石子。两人轮流从任意一堆数量不为0石子堆中取走任意数量的石子，小胡先取。取走最后一颗石子的人获胜。
假如双方都足够聪明，一定会采取当前局面下的最优策略，游戏的最终获胜者是谁？

**输入**
两个整数，分别代表a，b (0 < a, b < 1e9)

**输出**
如果最终小胡获胜，则输出"hlyyds!!!",如果最终小周获胜，则输出"xbyyds!!!"

>样例输入
2 1

>样例输出
hlyyds!!!

>提示
小胡先取走第一堆石子中 1颗石子，此时第一堆石子剩余1颗，第二堆石子剩余1颗，那么无论小周怎么拿，都是小胡获胜

### 题目分析
这道题更是逆天,我看出来了是博弈论,但是我不会博弈论,我刚好资料还带了洛谷的书,于是一顿翻,结果是没有翻到,然后我就只能自己慢慢推了,但是我一开始就走上了歪路,我一直觉得是跟两堆石头的奇偶性有关,于是就不停的推,一直都答案错误,知道比赛快结束了,才发现原来是a==b的时候周铭轩赢,不然其他任何情况都是胡意丰赢
当然原题 `nim的游戏`不是这么简单的规律

## 【模板】Nim 游戏

### 题目描述

甲，乙两个人玩 nim 取石子游戏。

nim 游戏的规则是这样的：地上有 $n$ 堆石子（每堆石子数量小于 $10^4$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这 $n$ 堆石子的数量，他想知道是否存在先手必胜的策略。

### 输入格式

**本题有多组测试数据。**

第一行一个整数 $T$ （$T\le10$），表示有 $T$ 组数据

接下来每两行是一组数据，第一行一个整数 $n$，表示有 $n$ 堆石子，$n\le10^4$。

第二行有 $n$ 个数，表示每一堆石子的数量.

### 输出格式

共 $T$ 行，每行表示如果对于这组数据存在先手必胜策略则输出 `Yes`，否则输出 `No`。

### 样例 #1

#### 样例输入 #1

```
2
2
1 1
2
1 0
```

#### 样例输出 #1

```
No
Yes
```
### 题目分析
这就是nim游戏与校赛题的不同之处,校赛题是固定的两堆石头,而nim的游戏是不固定的n堆石头,这里可以直接给出结论,因为这个结论我是推不出的,如果所有石子异或和为0,那么先手必输

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int tmp;
            cin >> tmp;
            ans ^= tmp;
        }
        if (!ans) cout << "No" << endl;
        else cout << "Yes" << endl;
    }
}
```
## 优雅的队列
`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
一个队列是由许多的成员构成的，但是这个队列是特殊的，因为队列的成员们都是由 0 和 1 构成的，每个成员都可以用 0 和 1 组成的字符串 S 来表示，例如10、01和11等。现在选出了由 n 个成员组成的队列，为了符合大众的审美标准，一个队列是否优雅是由成员们的排列顺序决定的。

定义队列为优雅的条件为：最终所形成的队列，成员们的排列顺序在字典序上是最小的。

**输入**
第一行，包含一个整数 n $（1 \leq n \leq 2 \times 10^5)$

接下来输入 n 行，每行输入一个二进制字符串 $S_i$ 表示为第 $i$ 个成员

**输出**
输出一个字符串，表示优雅队列的排列情况

>样例输入
3
111
000
101

>样例输出 
000101111

>提示
字典序最小的排列应该是 $S_2 S_3 S_1$，形成的队列为: 000101111

### 题目分析
这道题可以说是最令我伤心的一道题了,因为这道题我在洛谷上做过原题,但我比赛的时候完全一点没想起来,我尝试了全排列,结果是超时,尝试了前导零排序,但是我需要排完序后把零删掉,我最后没有写出来
这道题的正解就是一个特别的排序方式,在比较器中比较的是a+b和b+a的值,用这种巧妙的方法去避免排序时因为字符串位数不相同导致的字典序排序错误

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    vector<string> a(n);
    for (int i = 0; i < n;i++){
        cin >> a[i];
    }
    string ans = "";
    sort(a.begin(), a.end(),[](string a,string b){
        return a + b > b + a;
    });
    for (int i = 0; i < n;i++){
        ans += a[i];
    }
    cout << ans;
    return 0;
}
```

## 优化Σ

`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
在竞赛中经常会出现双重求和并且不能以$O(n^2)$的时间复杂度实现，这就需要我们去掌握优化∑的能力。

现给定长度为n的正整数数组a、长度为m的正整数数组b、正整数c，求 

$$\sum_{i=1}^{n}\sum_{j=1}^{m}a_i \times b_j \times c$$
**输入**
第一行三个正整数$n、m、c$

第二行n个正整数，表示正整数数组$a$

第二行m个正整数，表示正整数数组$b$

$1≤ n≤ 10^5$

$1≤ m≤ 10^5$

$1≤ c≤ 10^5$

$1≤ a_i, b_i≤ 10^5$

**输出**
一个整数表示最终答案，答案请对$10^9+7$取模

>样例输入
5 5 5
1 1 1 1 1
2 2 2 2 2

>样例输出 
25

### 题目分析
直接暴力是会超时的,我们对这个公式进行一些化简
我们可以通过交换律和分配律来化简这个表达式。首先，我们可以把常数 $c$ 提出来，因为它不依赖于任何求和索引：
$$ c \cdot \sum_{i=1}^{n}\sum_{j=1}^{m}a_i \times b_j $$

然后，我们注意到内部的求和 $ \sum_{j=1}^{m}a_i \times b_j $ 可以被看作是对于每一个固定的 $a_i$，所有 $b_j$ 的加权和。由于 $a_i$在对 $j$ 的求和中保持不变，我们可以把它提到内层求和外面,这表示我们首先对所有的 $b_j$, 求和得到一个固定值，然后用这个值与每一个 $a_i$ 相乘，再对所有的 $a_i$ 求和。现在我们可以看到，外层求和中的每一项都包含了一个相同的因子 $ \sum_{j=1}^{m}b_j $。因此，我们可以把这个因子提出来：
$$ c \cdot  \sum_{i=1}^{n}a_i \  \cdot  \sum_{j=1}^{m}b_j  $$
这样我们就可以在输入时预处理a和b的累加,时间就会快很多

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n, m, c;
    cin >> n >> m >> c;
    vector<int> a(n + 1);
    vector<int> b(m + 1);
    int suma = 0, sumb = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        suma += a[i];
    }
    for (int i = 0; i < m; i++) {
        cin >> b[i];
        sumb += b[i];
    }

    cout << (((sumb* suma)%1000000007)* c) %1000000007;

    return 0;
}
```
值得注意的是,在我们输出结果的时候,我们需要先对a和b的累加相乘的结果取模再对整个结果取模,不然结果可能会爆long long,或者直接用高精度,但是cpp肯定是直接取模快的.

# A*算法启发式搜索专项
## 八数码
### 题目背景
八数码问题是一个经典的问题，它是一个启发式搜索问题，也是人工智能领域的经典问题之一。在这个问题中，我们需要将一个 $3\times 3$ 的九宫格中的数字 $1$ 到 $8$ 和一个空格排成目标状态。我们可以通过上下左右移动空格，将九宫格中的数字移动到目标状态。我们需要找到最少的移动次数，将初始状态移动到目标状态。 我们需要打印出移动的路径。
### 方法一:暴力BFS+康托展开
#### 思路
我们可以使用BFS搜索的方法，从初始状态开始，每次将当前状态的所有可能状态加入队列，直到找到目标状态。我们可以使用康托展开将状态压缩成一个数，这样我们就可以使用一个数组来记录状态是否访问过.我们可以使用一个数组来记录每个状态的父节点，这样我们就可以从目标状态开始，一直找到初始状态，从而找到路径。
这里用了老师的代码,我的代码的随机是伪随机数,每次运行都是一样的
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
class Pt {
  private:
    char str[9];
    int loc9;
    int step;
    int father;
    int inverse_number() const {
        int i, j, sum = 0;
        for (i = 1; i < 9; ++i)
            for (j = 0; j < i; ++j)
                if (str[j] != '9' && str[i] < str[j])
                    ++sum;
        return sum;
    }
    void my_shuffle() {
        int i, x, y;
        for (i = 0; i < 10; ++i) {
            x = rand() % 9;
            y = rand() % 9;
            if (x != y) {
                char t = str[x];
                str[x] = str[y];
                str[y] = t;
            }
        }
    }
    bool test() const {
        int i;
        for (i = 0; i < 8; ++i)
            if (str[i] != i + '1')
                return 0;
        return 1;
    }

    void show() const {
        bool flag = test();
        int i;
        char t = flag ? '9' : ' ';
        for (i = 0; i < 9; ++i)
            if (i % 3 == 2)
                cout << (str[i] == '9' ? t : str[i]) << endl;
            else
                cout << (str[i] == '9' ? t : str[i]) << ' ';
        cout << "第" << step << "步---------------\n";
    }

    int cantor() const {
        static const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};
        int i, j, t, sum = 0;
        for (i = 0; i < 8; ++i) {
            t = 0;
            for (j = i + 1; j < 9; ++j)
                if (str[i] > str[j])
                    ++t;
            sum += t * fac[i];
        }
        return sum;
    }
    void show(const Pt *queue, int index) const {
        if (index != -1) {
            show(queue, queue[index].father);
            queue[index].show();
        }
    }

  public:
    Pt() {}
    void random_init() {
        int i;
        for (i = 0; i < 9; ++i)
            str[i] = '1' + i;
        while (my_shuffle(), inverse_number() % 2 == 1);
        for (i = 0; str[i] != '9'; ++i);
        loc9 = i;
        father = -1;
        step = 0;
    }
    void bfs() const {
        if (test()) {
            show();
            return;
        }
        int i, dir[4] = {-3, 3, -1, 1};
        bool *flag = new bool[362880];
        memset(flag, 0, sizeof(bool) * 362880);
        Pt cur = *this, *queue = new Pt[362880 / 2];
        int front = 0, rear = 0;
        flag[cur.cantor()] = 1;
        queue[rear++] = cur;
        while (front < rear) {
            cur = queue[front++];
            for (i = 0; i < 4; ++i) {
                Pt tmp = cur;
                tmp.step = cur.step + 1;
                int x = tmp.loc9 / 3, y = tmp.loc9 % 3;
                if (x == 0 && i == 0 || x == 2 && i == 1 || y == 0 && i == 2 ||
                    y == 2 && i == 3)
                    continue;
                tmp.str[tmp.loc9] = tmp.str[tmp.loc9 + dir[i]];
                tmp.loc9 += dir[i];
                tmp.str[tmp.loc9] = '9';
                tmp.father = front - 1;
                int tmp_cantor = tmp.cantor();
                if (!flag[tmp_cantor]) {
                    flag[tmp_cantor] = 1;
                    queue[rear++] = tmp;
                    if (tmp.test()) {
                        show(queue, rear - 1);
                        delete[] queue;
                        delete[] flag;
                        return;
                    }
                }
            }
        }
    }
};

int main() {
    // srand(time(0));
    Pt pt;
    pt.random_init();
    pt.bfs();
    return 0;
}
```
### 方法二: A*算法+康托展开+曼哈顿距离
#### 思路
我们可以使用$A^*$算法来解决这个问题，$A^*$算法是一种启发式搜索算法，它可以在搜索的过程中，根据启发函数来选择下一个状态。我们可以使用曼哈顿距离作为启发函数，曼哈顿距离是指每个数字到目标位置的距离之和。$A^*$算法定义起点$s$,终点$t$,从起点(初始函数)开始的距离函数$g(x)$,到终点(最终状态)的距离函数$h(x)$,$h^*(x)$ ,以及每个点的估价函数$f(x) = g(x) + h(x)$。$A*$的实现是通过一个优先队列来实现的，每次从队列中取出估价函数最小的点，然后将这个点的所有邻接点加入队列，直到找到目标状态。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
class Pt {
  private:
    char str[9];
    int loc9;
    int step;
    int father;
    int manhattan_dis;
    int inverse_number() const {
        int i, j, sum = 0;
        for (i = 1; i < 9; ++i)
            for (j = 0; j < i; ++j)
                if (str[j] != '9' && str[i] < str[j])
                    ++sum;
        return sum;
    }
    void my_shuffle() {
        int i, x, y;
        for (i = 0; i < 10; ++i) {
            x = rand() % 9;
            y = rand() % 9;
            if (x != y) {
                char t = str[x];
                str[x] = str[y];
                str[y] = t;
            }
        }
    }
    bool test() const {
        int i;
        for (i = 0; i < 8; ++i)
            if (str[i] != i + '1')
                return 0;
        return 1;
    }
    struct Compare {
        Pt *q;
        Compare(Pt *p) : q(p) {}
        bool operator()(int a, int b) const {
            return q[a].step + q[a].manhattan_dis >
                   q[b].step + q[b].manhattan_dis;
        }
    };
    void show() const {
        bool flag = test();
        int i;
        char t = flag ? '9' : ' ';
        for (i = 0; i < 9; ++i)
            if (i % 3 == 2)
                cout << (str[i] == '9' ? t : str[i]) << endl;
            else
                cout << (str[i] == '9' ? t : str[i]) << ' ';
        cout << "第" << step << "步---------------\n";
    }

    int cantor() const {
        static const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};
        int i, j, t, sum = 0;
        for (i = 0; i < 8; ++i) {
            t = 0;
            for (j = i + 1; j < 9; ++j)
                if (str[i] > str[j])
                    ++t;
            sum += t * fac[i];
        }
        return sum;
    }
    void show(const Pt *queue, int index) const {
        if (index != -1) {
            show(queue, queue[index].father);
            queue[index].show();
        }
    }
    int manhattan() const {
        int i, sum = 0;
        for (i = 0; i < 9; ++i)
            if (str[i] != '9')
                sum += abs((str[i] - '1') / 3 - i / 3) +
                       abs((str[i] - '1') % 3 - i % 3);

        return sum;
    }

  public:
    Pt() {}
    void random_init() {
        int i;
        for (i = 0; i < 9; ++i)
            str[i] = '1' + i;
        while (my_shuffle(), inverse_number() % 2 == 1)
            ;
        for (i = 0; str[i] != '9'; ++i)
            ;
        loc9 = i;
        father = -1;
        step = 0;
        manhattan_dis = manhattan();
    }
    void A_star() const {
        if (test()) {
            show();
            return;
        }
        int i, dir[4] = {-3, 3, -1, 1};
        bool *flag = new bool[362880];
        memset(flag, 0, sizeof(bool) * 362880);
        Pt cur = *this, *queue = new Pt[362880 / 2];
        Compare compare(queue);
        int *heap = new int[362880 / 2];
        int heap_len = 0, rear = 0;
        flag[cur.cantor()] = 1;
        queue[rear++] = cur;
        heap[heap_len++] = 0;
        while (heap_len) {
            int father = heap[0];
            cur = queue[father];
            pop_heap(heap, heap + heap_len, compare);
            --heap_len;
            for (i = 0; i < 4; ++i) {
                Pt tmp = cur;
                int x = tmp.loc9 / 3, y = tmp.loc9 % 3;
                if (x == 0 && i == 0 || x == 2 && i == 1 || y == 0 && i == 2 ||
                    y == 2 && i == 3)
                    continue;
                tmp.str[tmp.loc9] = tmp.str[tmp.loc9 + dir[i]];
                tmp.loc9 += dir[i];
                tmp.str[tmp.loc9] = '9';
                tmp.father = father;
                int tmp_cantor = tmp.cantor();
                if (!flag[tmp_cantor]) {
                    flag[tmp_cantor] = 1;
                    tmp.step = cur.step + 1;
                    tmp.manhattan_dis = tmp.manhattan();
                    heap[heap_len++] = rear;
                    queue[rear++] = tmp;
                    push_heap(heap, heap + heap_len, compare);
                    if (tmp.test()) {
                        show(queue, rear - 1);
                        delete[] queue;
                        delete[] flag;
                        delete[] heap;
                        return;
                    }
                }
            }
        }
    }
};

int main() {
    // srand(time(0));
    Pt pt;
    pt.random_init();
    pt.A_star();
    return 0;
}
```
#### 复杂度分析
时间复杂度为$O(n!)$，空间复杂度为$O(n!)$。
### 方法三: IDA*算法+康托展开+曼哈顿距离
#### 思路
我们可以使用$IDA*$算法来解决这个问题，$IDA*$和$A*$不同的是,$IDA*$不再用小根堆,而是用dfs的思想,每次搜索的时候,我们都会设定一个阈值,如果当前状态的估价函数大于阈值,我们就不再搜索这个状态,如果小于阈值,我们就继续搜索。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
class Pt {
  private:
    char str[9];
    int loc9;
    int step;
    int father;
    int manhattan_dis;
    int inverse_number() const {
        int i, j, sum = 0;
        for (i = 1; i < 9; ++i)
            for (j = 0; j < i; ++j)
                if (str[j] != '9' && str[i] < str[j])
                    ++sum;
        return sum;
    }
    void my_shuffle() {
        int i, x, y;
        for (i = 0; i < 10; ++i) {
            x = rand() % 9;
            y = rand() % 9;
            if (x != y) {
                char t = str[x];
                str[x] = str[y];
                str[y] = t;
            }
        }
    }
    bool test() const {
        int i;
        for (i = 0; i < 8; ++i)
            if (str[i] != i + '1')
                return 0;
        return 1;
    }
    struct Compare {
        Pt *q;
        Compare(Pt *p) : q(p) {}
        bool operator()(int a, int b) const {
            return q[a].step + q[a].manhattan_dis >
                   q[b].step + q[b].manhattan_dis;
        }
    };
    void show() const {
        bool flag = test();
        int i;
        char t = flag ? '9' : ' ';
        for (i = 0; i < 9; ++i)
            if (i % 3 == 2)
                cout << (str[i] == '9' ? t : str[i]) << endl;
            else
                cout << (str[i] == '9' ? t : str[i]) << ' ';
        cout << "第" << step << "步---------------\n";
    }

    int cantor() const {
        static const int fac[] = {40320, 5040, 720, 120, 24, 6, 2, 1, 1};
        int i, j, t, sum = 0;
        for (i = 0; i < 8; ++i) {
            t = 0;
            for (j = i + 1; j < 9; ++j)
                if (str[i] > str[j])
                    ++t;
            sum += t * fac[i];
        }
        return sum;
    }
    void show(const Pt *queue, int index) const {
        if (index != -1) {
            show(queue, queue[index].father);
            queue[index].show();
        }
    }
    int manhattan() const {
        int i, sum = 0;
        for (i = 0; i < 9; ++i)
            if (str[i] != '9')
                sum += abs((str[i] - '1') / 3 - i / 3) +
                       abs((str[i] - '1') % 3 - i % 3);

        return sum;
    }

  public:
    Pt() {}
    void random_init() {
        int i;
        for (i = 0; i < 9; ++i)
            str[i] = '1' + i;
        while (my_shuffle(), inverse_number() % 2 == 1)
            ;
        for (i = 0; str[i] != '9'; ++i)
            ;
        loc9 = i;
        father = -1;
        step = 0;
        manhattan_dis = manhattan();
    }
    void ID_A_star() const{
        if (test()){
            show();
            return;
        }
        int max_d = 0;
        bool finished = 0;
        Pt ans[64];
        ans[0] = *this;
        while (!finished){
            dfs(ans, 0, max_d, finished);
            ++max_d;
        }
    }
    void dfs(Pt *ans, int d, int max_d, bool &finished) const{
        int i;
        static const int dir[4] = {-3, 3, -1, 1};
        int dis = ans[d].manhattan();
        if (!dis){
            for (i = 0; i <= d; ++i){
                ans[i].step = i;
                ans[i].show();
            }
            finished = 1;
            return;
        }
        if (d + dis <= max_d && !finished){
            for (i = 0; i < 4; ++i){
                int x = ans[d].loc9 / 3, y = ans[d].loc9 % 3;
                if (x == 0 && i == 0 || x == 2 && i == 1 || y == 0 && i == 2 ||
                    y == 2 && i == 3)
                    continue;
                ans[d + 1] = ans[d];
                ans[d + 1].str[ans[d].loc9] = ans[d].str[ans[d].loc9 + dir[i]];
                ans[d + 1].loc9 += dir[i];
                ans[d + 1].str[ans[d + 1].loc9] = '9';
                dfs(ans, d + 1, max_d, finished);
            }
        }
    }
};

int main() {
    // srand(time(0));
    Pt pt;
    pt.random_init();
    pt.ID_A_star();
    return 0;
}
```
