# 7月12日
<style>
     a {
            color: black;
            font-size: 20px;

        }
</style>
<big><a>今天讲了昨天校赛的题</a></big>

## 扶老奶奶过马路
`内存限制：128 MB
时间限制：1.000 S
评测方式：文本比较`

### 题目描述
有一群小朋友扶一群老奶奶过马路，但小朋友只记住了扶老奶奶过马路是“做好事”，却忽略了老奶奶是否有过马路的真实需求。 就出现了，把老奶奶扶过去，又扶回来的情况。 假设，有N位老奶奶站在马路东侧，编号1至N，第1分钟，把所有编号能够被1整除的老奶奶扶到马路对面（即所有老奶奶从东侧到西侧，因为所有数被1除，都余0）； 第2分钟，把所有编号能够被2整除的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧，例如2号老奶奶，第1分钟被从东扶到西，第2分钟又被扶着回来）； 第3分钟，把所有编号能够被3整除的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧）；$\cdots \cdots$； 第N分钟，把所有能够被N整除编号的老奶奶扶到马路对面（东侧的到西侧，西侧的到东侧）； 问:最后，马路东侧有多少老奶奶，即多少老奶奶没有过马路？
**输入**
输入有两行： 

第一行为测试案例的个数$M$；

第二行是M个整数，每个整数对应一个测试数据的N。$(1 \leq N \leq 10^9)$

输出
你的输出应该有$M$行，每行一个整数，表示与输入对应的答案

>样例输入
2
1 5

>样例输出
0
3

>提示
以N=5为例，第1分钟，1、2、3、4、5从东到西;第2分钟，2、4从西到东；第3分钟，3从西到东；第4分钟，4从东到西；第5分钟，5从西到东；最后，2、3、5在东侧，1、4在西侧。

### 题目分析
这道题比赛的时候真是难倒我了
我一直都找不出它的规律,尤其是在老师说它的核心代码超过三行都算失败的时候,我找规律的思路一开始就歪了,因为我一直都在往分解素因子内方面想,知道我模拟了十个人过马路的时候,我才看出来原来马路右边的也就是不选的是1,2,4,9,也就是平方数,但是遍历去平方数会超时,于是简单推导一下他的公式吧,很简单就可以得到
$$ A=x-\left\lfloor\sqrt{x}  \right\rfloor $$

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n;
    cin >> n;
    while (n--) {
        int a;
        cin >> a;
        int ans =sqrt(a);
        cout << a-ans << endl;
    }
    return 0;
}
```
### 拓展联想
写完我才发现,这不是开关灯吗 题目在这里
## 开灯

### 题目背景

该题的题目是不是感到很眼熟呢?

事实上，如果你懂的方法，该题的代码简直不能再短。

但是如果你不懂得呢？那。。。（自己去想）

### 题目描述

首先所有的灯都是关的（注意是关！），编号为 $1$ 的人走过来，把是 $1$ 的倍数的灯全部打开，编号为 $2$ 的人把是 $2$ 的倍数的灯全部关上，编号为 $3$ 的人又把是 $3$ 的倍数的灯开的关上，关的开起来……直到第 $N$ 个人为止。

给定 $N$，求 $N$ 轮之后，还有哪几盏是开着的。

### 输入格式

一个数 $N$，表示灯的个数和操作的轮数。

### 输出格式

若干数，表示开着的电灯编号。

### 样例 #1

#### 样例输入 #1

```
5
```

#### 样例输出 #1

```
1 4
```

### 提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le N \le 2^{40}$。

**【其他说明】**

数学题！
### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for (int i = 1; i <= sqrt(n);i++){
        cout << i * i << " ";
    }
        return 0;
}
```
写过的题想半天是真的很令人难受
## xc的game
`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
小胡和小周在玩游戏，游戏的规则如下：现在有 2 堆石子，各有 a，b 颗石子。两人轮流从任意一堆数量不为0石子堆中取走任意数量的石子，小胡先取。取走最后一颗石子的人获胜。
假如双方都足够聪明，一定会采取当前局面下的最优策略，游戏的最终获胜者是谁？

**输入**
两个整数，分别代表a，b (0 < a, b < 1e9)

**输出**
如果最终小胡获胜，则输出"hlyyds!!!",如果最终小周获胜，则输出"xbyyds!!!"

>样例输入
2 1

>样例输出
hlyyds!!!

>提示
小胡先取走第一堆石子中 1颗石子，此时第一堆石子剩余1颗，第二堆石子剩余1颗，那么无论小周怎么拿，都是小胡获胜

### 题目分析
这道题更是逆天,我看出来了是博弈论,但是我不会博弈论,我刚好资料还带了洛谷的书,于是一顿翻,结果是没有翻到,然后我就只能自己慢慢推了,但是我一开始就走上了歪路,我一直觉得是跟两堆石头的奇偶性有关,于是就不停的推,一直都答案错误,知道比赛快结束了,才发现原来是a==b的时候周铭轩赢,不然其他任何情况都是胡意丰赢
当然原题 `nim的游戏`不是这么简单的规律
## 【模板】Nim 游戏

### 题目描述

甲，乙两个人玩 nim 取石子游戏。

nim 游戏的规则是这样的：地上有 $n$ 堆石子（每堆石子数量小于 $10^4$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这 $n$ 堆石子的数量，他想知道是否存在先手必胜的策略。

### 输入格式

**本题有多组测试数据。**

第一行一个整数 $T$ （$T\le10$），表示有 $T$ 组数据

接下来每两行是一组数据，第一行一个整数 $n$，表示有 $n$ 堆石子，$n\le10^4$。

第二行有 $n$ 个数，表示每一堆石子的数量.

### 输出格式

共 $T$ 行，每行表示如果对于这组数据存在先手必胜策略则输出 `Yes`，否则输出 `No`。

### 样例 #1

#### 样例输入 #1

```
2
2
1 1
2
1 0
```

#### 样例输出 #1

```
No
Yes
```
### 题目分析
这就是nim游戏与校赛题的不同之处,校赛题是固定的两堆石头,而nim的游戏是不固定的n堆石头,这里可以直接给出结论,因为这个结论我是推不出的,如果所有石子异或和为0,那么先手必输

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int tmp;
            cin >> tmp;
            ans ^= tmp;
        }
        if (!ans) cout << "No" << endl;
        else cout << "Yes" << endl;
    }
}
```
## 优雅的队列
`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
一个队列是由许多的成员构成的，但是这个队列是特殊的，因为队列的成员们都是由 0 和 1 构成的，每个成员都可以用 0 和 1 组成的字符串 S 来表示，例如10、01和11等。现在选出了由 n 个成员组成的队列，为了符合大众的审美标准，一个队列是否优雅是由成员们的排列顺序决定的。

定义队列为优雅的条件为：最终所形成的队列，成员们的排列顺序在字典序上是最小的。

**输入**
第一行，包含一个整数 n $（1 \leq n \leq 2 \times 10^5)$

接下来输入 n 行，每行输入一个二进制字符串 $S_i$ 表示为第 $i$ 个成员

**输出**
输出一个字符串，表示优雅队列的排列情况

>样例输入
3
111
000
101

>样例输出 
000101111

>提示
字典序最小的排列应该是 $S_2 S_3 S_1$，形成的队列为: 000101111

### 题目分析
这道题可以说是最令我伤心的一道题了,因为这道题我在洛谷上做过原题,但我比赛的时候完全一点没想起来,我尝试了全排列,结果是超时,尝试了前导零排序,但是我需要排完序后把零删掉,我最后没有写出来
这道题的正解就是一个特别的排序方式,在比较器中比较的是a+b和b+a的值,用这种巧妙的方法去避免排序时因为字符串位数不相同导致的字典序排序错误

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin >> n;
    vector<string> a(n);
    for (int i = 0; i < n;i++){
        cin >> a[i];
    }
    string ans = "";
    sort(a.begin(), a.end(),[](string a,string b){
        return a + b > b + a;
    });
    for (int i = 0; i < n;i++){
        ans += a[i];
    }
    cout << ans;
    return 0;
}
```

## 优化Σ

`内存限制：128 MB
时间限制：1.000 S`

### 题目描述
在竞赛中经常会出现双重求和并且不能以$O(n^2)$的时间复杂度实现，这就需要我们去掌握优化∑的能力。

现给定长度为n的正整数数组a、长度为m的正整数数组b、正整数c，求 

$$\sum_{i=1}^{n}\sum_{j=1}^{m}a_i \times b_j \times c$$
**输入**
第一行三个正整数$n、m、c$

第二行n个正整数，表示正整数数组$a$

第二行m个正整数，表示正整数数组$b$

$1≤ n≤ 10^5$

$1≤ m≤ 10^5$

$1≤ c≤ 10^5$

$1≤ a_i, b_i≤ 10^5$

**输出**
一个整数表示最终答案，答案请对$10^9+7$取模

>样例输入
5 5 5
1 1 1 1 1
2 2 2 2 2

>样例输出 
25

### 题目分析
直接暴力是会超时的,我们对这个公式进行一些化简
我们可以通过交换律和分配律来化简这个表达式。首先，我们可以把常数 $c$ 提出来，因为它不依赖于任何求和索引：
$$ c \cdot \sum_{i=1}^{n}\sum_{j=1}^{m}a_i \times b_j $$

然后，我们注意到内部的求和 $\sum_{j=1}^{m}a_i \times b_j$可以被看作是对于每一个固定的 $a_i$，所有 $b_j$ 的加权和。由于 $a_i$在对 $j$ 的求和中保持不变，我们可以把它提到内层求和外面,这表示我们首先对所有的 $b_j$, 求和得到一个固定值，然后用这个值与每一个 $a_i$ 相乘，再对所有的 $a_i$ 求和。现在我们可以看到，外层求和中的每一项都包含了一个相同的因子 $ \sum_{j=1}^{m}b_j $。因此，我们可以把这个因子提出来：
$$ c \cdot  \sum_{i=1}^{n}a_i \  \cdot  \sum_{j=1}^{m}b_j  $$
这样我们就可以在输入时预处理a和b的累加,时间就会快很多

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    int n, m, c;
    cin >> n >> m >> c;
    vector<int> a(n + 1);
    vector<int> b(m + 1);
    int suma = 0, sumb = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        suma += a[i];
    }
    for (int i = 0; i < m; i++) {
        cin >> b[i];
        sumb += b[i];
    }

    cout << (((sumb* suma)%1000000007)* c) %1000000007;

    return 0;
}
```
值得注意的是,在我们输出结果的时候,我们需要先对a和b的累加相乘的结果取模再对整个结果取模,不然结果可能会爆long long,或者直接用高精度,但是cpp肯定是直接取模快的.

